# Generated from ClickHouseParser.g4 by ANTLR 4.8
# encoding: utf-8
import sys
from io import StringIO

from antlr4 import *

if sys.version_info[1] > 5:
    from typing import TextIO
else:
    from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u00b4")
        buf.write("\u0490\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write('\4\37\t\37\4 \t \4!\t!\4"\t"\4#\t#\4$\t$\4%\t%\4&\t')
        buf.write("&\4'\t'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\t")
        buf.write("M\4N\tN\4O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\t")
        buf.write("V\3\2\3\2\5\2\u00af\n\2\3\2\3\2\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\5\3\u00c1\n\3\3\4\3")
        buf.write("\4\3\4\3\4\7\4\u00c7\n\4\f\4\16\4\u00ca\13\4\3\4\5\4\u00cd")
        buf.write("\n\4\3\4\5\4\u00d0\n\4\3\5\5\5\u00d3\n\5\3\5\3\5\5\5\u00d7")
        buf.write("\n\5\3\5\5\5\u00da\n\5\3\5\5\5\u00dd\n\5\3\5\5\5\u00e0")
        buf.write("\n\5\3\5\5\5\u00e3\n\5\3\5\5\5\u00e6\n\5\3\5\5\5\u00e9")
        buf.write("\n\5\3\5\5\5\u00ec\n\5\3\5\5\5\u00ef\n\5\3\5\5\5\u00f2")
        buf.write("\n\5\3\5\5\5\u00f5\n\5\3\5\5\5\u00f8\n\5\3\5\5\5\u00fb")
        buf.write("\n\5\3\6\3\6\3\6\3\7\3\7\5\7\u0102\n\7\3\7\3\7\3\b\3\b")
        buf.write("\3\b\3\b\5\b\u010a\n\b\3\b\5\b\u010d\n\b\3\t\5\t\u0110")
        buf.write("\n\t\3\t\3\t\3\t\3\t\3\n\3\n\3\n\3\n\5\n\u011a\n\n\3\13")
        buf.write("\3\13\3\13\5\13\u011f\n\13\3\f\5\f\u0122\n\f\3\f\3\f\3")
        buf.write("\f\3\f\5\f\u0128\n\f\3\f\3\f\5\f\u012c\n\f\3\f\3\f\5\f")
        buf.write("\u0130\n\f\5\f\u0132\n\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3")
        buf.write("\f\3\f\5\f\u013d\n\f\3\f\5\f\u0140\n\f\3\f\3\f\3\f\5\f")
        buf.write("\u0145\n\f\3\r\3\r\5\r\u0149\n\r\3\16\3\16\3\16\3\17\3")
        buf.write("\17\3\17\3\20\3\20\3\20\3\20\3\20\5\20\u0156\n\20\3\21")
        buf.write("\3\21\3\21\3\22\3\22\3\22\3\22\3\23\3\23\3\23\3\23\5\23")
        buf.write("\u0163\n\23\3\24\3\24\3\24\3\24\3\24\3\25\3\25\3\25\3")
        buf.write("\26\3\26\3\26\3\27\3\27\3\27\3\27\3\27\3\27\5\27\u0176")
        buf.write("\n\27\3\27\3\27\3\27\3\27\5\27\u017c\n\27\3\27\3\27\3")
        buf.write("\27\3\27\3\27\7\27\u0183\n\27\f\27\16\27\u0186\13\27\3")
        buf.write("\27\3\27\3\27\3\27\3\27\3\27\7\27\u018e\n\27\f\27\16\27")
        buf.write("\u0191\13\27\3\27\3\27\7\27\u0195\n\27\f\27\16\27\u0198")
        buf.write("\13\27\3\27\3\27\3\27\5\27\u019d\n\27\3\30\3\30\5\30\u01a1")
        buf.write("\n\30\3\30\3\30\3\30\3\30\5\30\u01a7\n\30\3\30\3\30\3")
        buf.write("\30\3\30\3\30\5\30\u01ae\n\30\3\30\3\30\3\30\3\30\5\30")
        buf.write("\u01b4\n\30\3\30\3\30\3\30\3\30\3\30\3\30\5\30\u01bc\n")
        buf.write("\30\3\30\3\30\3\30\3\30\3\30\3\30\3\30\3\30\5\30\u01c6")
        buf.write("\n\30\3\30\3\30\3\30\5\30\u01cb\n\30\3\30\5\30\u01ce\n")
        buf.write("\30\3\30\5\30\u01d1\n\30\3\30\3\30\3\30\3\30\3\30\5\30")
        buf.write("\u01d8\n\30\5\30\u01da\n\30\5\30\u01dc\n\30\3\30\5\30")
        buf.write("\u01df\n\30\3\30\3\30\3\30\3\30\5\30\u01e5\n\30\3\30\3")
        buf.write("\30\3\30\3\30\3\30\5\30\u01ec\n\30\3\30\5\30\u01ef\n\30")
        buf.write("\3\30\5\30\u01f2\n\30\3\30\3\30\3\30\5\30\u01f7\n\30\3")
        buf.write("\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31\7\31")
        buf.write("\u0203\n\31\f\31\16\31\u0206\13\31\3\31\3\31\3\31\5\31")
        buf.write("\u020b\n\31\3\32\3\32\3\32\3\32\5\32\u0211\n\32\3\32\3")
        buf.write("\32\3\32\3\32\5\32\u0217\n\32\3\32\3\32\3\32\5\32\u021c")
        buf.write("\n\32\3\32\3\32\3\32\3\32\5\32\u0222\n\32\5\32\u0224\n")
        buf.write("\32\3\33\3\33\3\33\3\33\3\33\3\33\5\33\u022c\n\33\3\33")
        buf.write("\3\33\3\33\7\33\u0231\n\33\f\33\16\33\u0234\13\33\3\34")
        buf.write("\3\34\3\34\3\34\3\34\5\34\u023b\n\34\3\34\3\34\3\34\3")
        buf.write("\34\3\34\3\34\3\34\3\34\3\34\3\34\3\34\3\34\3\34\3\34")
        buf.write("\3\34\3\34\3\34\3\34\3\34\3\34\3\34\3\34\3\34\3\34\5\34")
        buf.write("\u0255\n\34\3\35\3\35\3\35\3\35\3\35\3\35\7\35\u025d\n")
        buf.write("\35\f\35\16\35\u0260\13\35\3\35\3\35\3\35\3\35\3\35\3")
        buf.write("\35\3\35\3\35\3\35\3\35\3\35\3\35\7\35\u026e\n\35\f\35")
        buf.write("\16\35\u0271\13\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35")
        buf.write("\5\35\u027a\n\35\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3")
        buf.write("\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\7\36\u028b\n\36")
        buf.write("\f\36\16\36\u028e\13\36\3\36\3\36\3\36\3\36\3\36\3\36")
        buf.write("\3\36\7\36\u0297\n\36\f\36\16\36\u029a\13\36\3\36\3\36")
        buf.write("\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36")
        buf.write("\3\36\3\36\3\36\3\36\3\36\5\36\u02ae\n\36\3\37\3\37\3")
        buf.write('\37\3\37\3 \3 \3 \3!\3!\5!\u02b9\n!\3!\3!\3"\3"\3"')
        buf.write('\7"\u02c0\n"\f"\16"\u02c3\13"\3#\3#\3#\3#\3$\3$\3')
        buf.write("$\3$\3$\3$\3%\3%\3%\3%\3%\5%\u02d4\n%\3%\5%\u02d7\n%\3")
        buf.write("&\3&\3&\3&\5&\u02dd\n&\3&\3&\3&\5&\u02e2\n&\3&\3&\5&\u02e6")
        buf.write("\n&\3'\3'\3'\3'\3'\5'\u02ed\n'\3'\5'\u02f0\n")
        buf.write("'\3'\3'\5'\u02f4\n'\5'\u02f6\n'\3'\5'\u02f9\n")
        buf.write("'\3'\3'\5'\u02fd\n'\3(\3(\3(\5(\u0302\n(\3(\3(\5")
        buf.write("(\u0306\n(\3)\3)\3)\3)\3*\3*\3*\5*\u030f\n*\3*\3*\3+\3")
        buf.write("+\5+\u0315\n+\3,\3,\5,\u0319\n,\3-\3-\3.\3.\3/\3/\3\60")
        buf.write("\3\60\3\60\3\60\3\61\3\61\3\61\3\61\3\62\3\62\5\62\u032b")
        buf.write("\n\62\3\63\3\63\5\63\u032f\n\63\3\64\3\64\3\64\7\64\u0334")
        buf.write("\n\64\f\64\16\64\u0337\13\64\3\65\3\65\5\65\u033b\n\65")
        buf.write("\3\65\3\65\5\65\u033f\n\65\3\65\3\65\5\65\u0343\n\65\3")
        buf.write("\66\3\66\3\66\3\66\7\66\u0349\n\66\f\66\16\66\u034c\13")
        buf.write("\66\3\67\3\67\3\67\3\67\3\67\3\67\3\67\3\67\5\67\u0356")
        buf.write("\n\67\38\38\38\38\38\39\39\39\79\u0360\n9\f9\169\u0363")
        buf.write("\139\3:\3:\3:\3;\3;\3;\3<\3<\3<\7<\u036e\n<\f<\16<\u0371")
        buf.write("\13<\3=\3=\3=\3=\5=\u0377\n=\3=\3=\5=\u037b\n=\3=\3=\5")
        buf.write("=\u037f\n=\3>\3>\3?\3?\3@\3@\3@\7@\u0388\n@\f@\16@\u038b")
        buf.write("\13@\3A\3A\3A\7A\u0390\nA\fA\16A\u0393\13A\3B\3B\5B\u0397")
        buf.write("\nB\3C\5C\u039a\nC\3C\3C\3D\3D\3D\3E\3E\3F\3F\3G\3G\3")
        buf.write("G\3G\3H\3H\5H\u03ab\nH\3I\3I\3I\3I\3I\3I\3I\3I\5I\u03b5")
        buf.write("\nI\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\7I\u03c1\nI\fI\16I\u03c4")
        buf.write("\13I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3")
        buf.write("I\3I\3I\3I\3I\3I\3I\7I\u03dd\nI\fI\16I\u03e0\13I\3I\3")
        buf.write("I\3I\3I\3I\7I\u03e7\nI\fI\16I\u03ea\13I\5I\u03ec\nI\3")
        buf.write("I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\5I\u03fa\nI\3I\3I\3")
        buf.write("I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3")
        buf.write("I\3I\3I\3I\3I\3I\3I\3I\3I\3I\5I\u041a\nI\3I\3I\3I\3I\3")
        buf.write("I\3I\3I\3I\3I\3I\5I\u0426\nI\3I\3I\3I\3I\3I\3I\3I\3I\3")
        buf.write("I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\5I\u0440")
        buf.write("\nI\3I\3I\7I\u0444\nI\fI\16I\u0447\13I\3J\3J\3K\5K\u044c")
        buf.write("\nK\3L\3L\3L\7L\u0451\nL\fL\16L\u0454\13L\3M\3M\3M\3M")
        buf.write("\3N\3N\5N\u045c\nN\3N\3N\3O\3O\3O\3O\7O\u0464\nO\fO\16")
        buf.write("O\u0467\13O\5O\u0469\nO\3O\3O\3P\3P\3P\3P\7P\u0471\nP")
        buf.write("\fP\16P\u0474\13P\5P\u0476\nP\3P\3P\3Q\3Q\3R\3R\3R\3R")
        buf.write("\5R\u0480\nR\3S\3S\3T\3T\3T\3T\3T\5T\u0489\nT\3U\3U\3")
        buf.write("V\3V\3V\3V\2\3\u0090W\2\4\6\b\n\f\16\20\22\24\26\30\32")
        buf.write('\34\36 "$&(*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\\^`bdfh')
        buf.write("jlnprtvxz|~\u0080\u0082\u0084\u0086\u0088\u008a\u008c")
        buf.write("\u008e\u0090\u0092\u0094\u0096\u0098\u009a\u009c\u009e")
        buf.write("\u00a0\u00a2\u00a4\u00a6\u00a8\u00aa\2\17\4\2\6\6\n\n")
        buf.write("\4\2\20\20\32\32\4\2$$''\5\2\17\17aaee\4\2\36\36  \4")
        buf.write("\2\r\16\37 \4\2..AA\5\2\7\7##FF\5\2\177\177\u0085\u0085")
        buf.write("\u0087\u0087\4\2\u0080\u0080\u0086\u0086\t\2\34\34\66")
        buf.write("\66GGII\\\\qquu\22\2\4\23\25\25\27\30\32\33\36$&+-/\61")
        buf.write("\65\67:<FHHJ[]hjkmprt\4\2KK\u00b0\u00b1\2\u0516\2\u00ae")
        buf.write("\3\2\2\2\4\u00c0\3\2\2\2\6\u00c2\3\2\2\2\b\u00d2\3\2\2")
        buf.write("\2\n\u00fc\3\2\2\2\f\u00ff\3\2\2\2\16\u0105\3\2\2\2\20")
        buf.write("\u010f\3\2\2\2\22\u0115\3\2\2\2\24\u011b\3\2\2\2\26\u0144")
        buf.write("\3\2\2\2\30\u0148\3\2\2\2\32\u014a\3\2\2\2\34\u014d\3")
        buf.write('\2\2\2\36\u0150\3\2\2\2 \u0157\3\2\2\2"\u015a\3\2\2\2')
        buf.write("$\u015e\3\2\2\2&\u0164\3\2\2\2(\u0169\3\2\2\2*\u016c\3")
        buf.write("\2\2\2,\u016f\3\2\2\2.\u019e\3\2\2\2\60\u01f8\3\2\2\2")
        buf.write("\62\u020c\3\2\2\2\64\u0225\3\2\2\2\66\u0254\3\2\2\28\u0279")
        buf.write("\3\2\2\2:\u02ad\3\2\2\2<\u02af\3\2\2\2>\u02b3\3\2\2\2")
        buf.write("@\u02b6\3\2\2\2B\u02bc\3\2\2\2D\u02c4\3\2\2\2F\u02c8\3")
        buf.write("\2\2\2H\u02ce\3\2\2\2J\u02dc\3\2\2\2L\u02e7\3\2\2\2N\u02fe")
        buf.write("\3\2\2\2P\u0307\3\2\2\2R\u030e\3\2\2\2T\u0314\3\2\2\2")
        buf.write("V\u0318\3\2\2\2X\u031a\3\2\2\2Z\u031c\3\2\2\2\\\u031e")
        buf.write("\3\2\2\2^\u0320\3\2\2\2`\u0324\3\2\2\2b\u032a\3\2\2\2")
        buf.write("d\u032e\3\2\2\2f\u0330\3\2\2\2h\u0338\3\2\2\2j\u0344\3")
        buf.write("\2\2\2l\u034d\3\2\2\2n\u0357\3\2\2\2p\u035c\3\2\2\2r\u0364")
        buf.write("\3\2\2\2t\u0367\3\2\2\2v\u036a\3\2\2\2x\u0372\3\2\2\2")
        buf.write("z\u0380\3\2\2\2|\u0382\3\2\2\2~\u0384\3\2\2\2\u0080\u038c")
        buf.write("\3\2\2\2\u0082\u0394\3\2\2\2\u0084\u0399\3\2\2\2\u0086")
        buf.write("\u039d\3\2\2\2\u0088\u03a0\3\2\2\2\u008a\u03a2\3\2\2\2")
        buf.write("\u008c\u03a4\3\2\2\2\u008e\u03a8\3\2\2\2\u0090\u03f9\3")
        buf.write("\2\2\2\u0092\u0448\3\2\2\2\u0094\u044b\3\2\2\2\u0096\u044d")
        buf.write("\3\2\2\2\u0098\u0455\3\2\2\2\u009a\u0459\3\2\2\2\u009c")
        buf.write("\u045f\3\2\2\2\u009e\u046c\3\2\2\2\u00a0\u0479\3\2\2\2")
        buf.write("\u00a2\u047f\3\2\2\2\u00a4\u0481\3\2\2\2\u00a6\u0488\3")
        buf.write("\2\2\2\u00a8\u048a\3\2\2\2\u00aa\u048c\3\2\2\2\u00ac\u00af")
        buf.write("\5\4\3\2\u00ad\u00af\5\u00aaV\2\u00ae\u00ac\3\2\2\2\u00ae")
        buf.write("\u00ad\3\2\2\2\u00af\u00b0\3\2\2\2\u00b0\u00b1\7\2\2\3")
        buf.write("\u00b1\3\3\2\2\2\u00b2\u00c1\5L'\2\u00b3\u00c1\5\6\4")
        buf.write("\2\u00b4\u00c1\5,\27\2\u00b5\u00c1\5.\30\2\u00b6\u00c1")
        buf.write("\5\60\31\2\u00b7\u00c1\5\62\32\2\u00b8\u00c1\5\64\33\2")
        buf.write("\u00b9\u00c1\5> \2\u00ba\u00c1\5@!\2\u00bb\u00c1\5H%\2")
        buf.write("\u00bc\u00c1\5J&\2\u00bd\u00c1\5N(\2\u00be\u00c1\5P)\2")
        buf.write("\u00bf\u00c1\5F$\2\u00c0\u00b2\3\2\2\2\u00c0\u00b3\3\2")
        buf.write("\2\2\u00c0\u00b4\3\2\2\2\u00c0\u00b5\3\2\2\2\u00c0\u00b6")
        buf.write("\3\2\2\2\u00c0\u00b7\3\2\2\2\u00c0\u00b8\3\2\2\2\u00c0")
        buf.write("\u00b9\3\2\2\2\u00c0\u00ba\3\2\2\2\u00c0\u00bb\3\2\2\2")
        buf.write("\u00c0\u00bc\3\2\2\2\u00c0\u00bd\3\2\2\2\u00c0\u00be\3")
        buf.write("\2\2\2\u00c0\u00bf\3\2\2\2\u00c1\5\3\2\2\2\u00c2\u00c8")
        buf.write("\5\b\5\2\u00c3\u00c4\7n\2\2\u00c4\u00c5\7\6\2\2\u00c5")
        buf.write("\u00c7\5\b\5\2\u00c6\u00c3\3\2\2\2\u00c7\u00ca\3\2\2\2")
        buf.write("\u00c8\u00c6\3\2\2\2\u00c8\u00c9\3\2\2\2\u00c9\u00cc\3")
        buf.write("\2\2\2\u00ca\u00c8\3\2\2\2\u00cb\u00cd\5^\60\2\u00cc\u00cb")
        buf.write("\3\2\2\2\u00cc\u00cd\3\2\2\2\u00cd\u00cf\3\2\2\2\u00ce")
        buf.write("\u00d0\5*\26\2\u00cf\u00ce\3\2\2\2\u00cf\u00d0\3\2\2\2")
        buf.write("\u00d0\7\3\2\2\2\u00d1\u00d3\5\n\6\2\u00d2\u00d1\3\2\2")
        buf.write("\2\u00d2\u00d3\3\2\2\2\u00d3\u00d4\3\2\2\2\u00d4\u00d6")
        buf.write("\5\f\7\2\u00d5\u00d7\5\16\b\2\u00d6\u00d5\3\2\2\2\u00d6")
        buf.write("\u00d7\3\2\2\2\u00d7\u00d9\3\2\2\2\u00d8\u00da\7-\2\2")
        buf.write("\u00d9\u00d8\3\2\2\2\u00d9\u00da\3\2\2\2\u00da\u00dc\3")
        buf.write("\2\2\2\u00db\u00dd\5\22\n\2\u00dc\u00db\3\2\2\2\u00dc")
        buf.write("\u00dd\3\2\2\2\u00dd\u00df\3\2\2\2\u00de\u00e0\5\20\t")
        buf.write("\2\u00df\u00de\3\2\2\2\u00df\u00e0\3\2\2\2\u00e0\u00e2")
        buf.write("\3\2\2\2\u00e1\u00e3\5\26\f\2\u00e2\u00e1\3\2\2\2\u00e2")
        buf.write("\u00e3\3\2\2\2\u00e3\u00e5\3\2\2\2\u00e4\u00e6\5\32\16")
        buf.write("\2\u00e5\u00e4\3\2\2\2\u00e5\u00e6\3\2\2\2\u00e6\u00e8")
        buf.write("\3\2\2\2\u00e7\u00e9\5\34\17\2\u00e8\u00e7\3\2\2\2\u00e8")
        buf.write("\u00e9\3\2\2\2\u00e9\u00eb\3\2\2\2\u00ea\u00ec\5\36\20")
        buf.write("\2\u00eb\u00ea\3\2\2\2\u00eb\u00ec\3\2\2\2\u00ec\u00ee")
        buf.write("\3\2\2\2\u00ed\u00ef\5 \21\2\u00ee\u00ed\3\2\2\2\u00ee")
        buf.write('\u00ef\3\2\2\2\u00ef\u00f1\3\2\2\2\u00f0\u00f2\5"\22')
        buf.write("\2\u00f1\u00f0\3\2\2\2\u00f1\u00f2\3\2\2\2\u00f2\u00f4")
        buf.write("\3\2\2\2\u00f3\u00f5\5&\24\2\u00f4\u00f3\3\2\2\2\u00f4")
        buf.write("\u00f5\3\2\2\2\u00f5\u00f7\3\2\2\2\u00f6\u00f8\5$\23\2")
        buf.write("\u00f7\u00f6\3\2\2\2\u00f7\u00f8\3\2\2\2\u00f8\u00fa\3")
        buf.write("\2\2\2\u00f9\u00fb\5(\25\2\u00fa\u00f9\3\2\2\2\u00fa\u00fb")
        buf.write("\3\2\2\2\u00fb\t\3\2\2\2\u00fc\u00fd\7t\2\2\u00fd\u00fe")
        buf.write("\5\u0080A\2\u00fe\13\3\2\2\2\u00ff\u0101\7]\2\2\u0100")
        buf.write("\u0102\7&\2\2\u0101\u0100\3\2\2\2\u0101\u0102\3\2\2\2")
        buf.write("\u0102\u0103\3\2\2\2\u0103\u0104\5\u0080A\2\u0104\r\3")
        buf.write("\2\2\2\u0105\u0109\7/\2\2\u0106\u010a\5R*\2\u0107\u010a")
        buf.write("\5\u008aF\2\u0108\u010a\5\u008cG\2\u0109\u0106\3\2\2\2")
        buf.write("\u0109\u0107\3\2\2\2\u0109\u0108\3\2\2\2\u010a\u010c\3")
        buf.write("\2\2\2\u010b\u010d\5\u0084C\2\u010c\u010b\3\2\2\2\u010c")
        buf.write("\u010d\3\2\2\2\u010d\17\3\2\2\2\u010e\u0110\7B\2\2\u010f")
        buf.write("\u010e\3\2\2\2\u010f\u0110\3\2\2\2\u0110\u0111\3\2\2\2")
        buf.write("\u0111\u0112\7\13\2\2\u0112\u0113\7?\2\2\u0113\u0114\5")
        buf.write("\u0096L\2\u0114\21\3\2\2\2\u0115\u0116\7[\2\2\u0116\u0119")
        buf.write("\5\24\13\2\u0117\u0118\7M\2\2\u0118\u011a\5\24\13\2\u0119")
        buf.write("\u0117\3\2\2\2\u0119\u011a\3\2\2\2\u011a\23\3\2\2\2\u011b")
        buf.write("\u011e\7\u00b0\2\2\u011c\u011d\7\u0087\2\2\u011d\u011f")
        buf.write("\7\u00b0\2\2\u011e\u011c\3\2\2\2\u011e\u011f\3\2\2\2\u011f")
        buf.write("\25\3\2\2\2\u0120\u0122\7\63\2\2\u0121\u0120\3\2\2\2\u0121")
        buf.write("\u0122\3\2\2\2\u0122\u0123\3\2\2\2\u0123\u0131\t\2\2\2")
        buf.write("\u0124\u0132\79\2\2\u0125\u0127\7B\2\2\u0126\u0128\7j")
        buf.write("\2\2\u0127\u0126\3\2\2\2\u0127\u0128\3\2\2\2\u0128\u0132")
        buf.write("\3\2\2\2\u0129\u012b\7Z\2\2\u012a\u012c\7j\2\2\u012b\u012a")
        buf.write("\3\2\2\2\u012b\u012c\3\2\2\2\u012c\u0132\3\2\2\2\u012d")
        buf.write("\u012f\7\62\2\2\u012e\u0130\7j\2\2\u012f\u012e\3\2\2\2")
        buf.write("\u012f\u0130\3\2\2\2\u0130\u0132\3\2\2\2\u0131\u0124\3")
        buf.write("\2\2\2\u0131\u0125\3\2\2\2\u0131\u0129\3\2\2\2\u0131\u012d")
        buf.write("\3\2\2\2\u0132\u0133\3\2\2\2\u0133\u0134\7?\2\2\u0134")
        buf.write("\u013c\5\30\r\2\u0135\u0136\7p\2\2\u0136\u0137\7y\2\2")
        buf.write("\u0137\u0138\5\u0096L\2\u0138\u0139\7z\2\2\u0139\u013d")
        buf.write("\3\2\2\2\u013a\u013b\7p\2\2\u013b\u013d\5\u0096L\2\u013c")
        buf.write("\u0135\3\2\2\2\u013c\u013a\3\2\2\2\u013d\u0145\3\2\2\2")
        buf.write("\u013e\u0140\7\63\2\2\u013f\u013e\3\2\2\2\u013f\u0140")
        buf.write("\3\2\2\2\u0140\u0141\3\2\2\2\u0141\u0142\7\33\2\2\u0142")
        buf.write("\u0143\7?\2\2\u0143\u0145\5\30\r\2\u0144\u0121\3\2\2\2")
        buf.write("\u0144\u013f\3\2\2\2\u0145\27\3\2\2\2\u0146\u0149\5\u00a2")
        buf.write("R\2\u0147\u0149\5\u008cG\2\u0148\u0146\3\2\2\2\u0148\u0147")
        buf.write("\3\2\2\2\u0149\31\3\2\2\2\u014a\u014b\7U\2\2\u014b\u014c")
        buf.write("\5\u008eH\2\u014c\33\3\2\2\2\u014d\u014e\7s\2\2\u014e")
        buf.write("\u014f\5\u008eH\2\u014f\35\3\2\2\2\u0150\u0151\7\64\2")
        buf.write("\2\u0151\u0152\7\22\2\2\u0152\u0155\5\u0096L\2\u0153\u0154")
        buf.write("\7t\2\2\u0154\u0156\7g\2\2\u0155\u0153\3\2\2\2\u0155\u0156")
        buf.write("\3\2\2\2\u0156\37\3\2\2\2\u0157\u0158\7\65\2\2\u0158\u0159")
        buf.write("\5\u008eH\2\u0159!\3\2\2\2\u015a\u015b\7P\2\2\u015b\u015c")
        buf.write("\7\22\2\2\u015c\u015d\5f\64\2\u015d#\3\2\2\2\u015e\u015f")
        buf.write("\7D\2\2\u015f\u0162\7\u00b0\2\2\u0160\u0161\7w\2\2\u0161")
        buf.write("\u0163\7\u00b0\2\2\u0162\u0160\3\2\2\2\u0162\u0163\3\2")
        buf.write("\2\2\u0163%\3\2\2\2\u0164\u0165\7D\2\2\u0165\u0166\7\u00b0")
        buf.write("\2\2\u0166\u0167\7\22\2\2\u0167\u0168\5\u0096L\2\u0168")
        buf.write("'\3\2\2\2\u0169\u016a\7_\2\2\u016a\u016b\5B\"\2\u016b")
        buf.write(")\3\2\2\2\u016c\u016d\7\61\2\2\u016d\u016e\5\u00a2R\2")
        buf.write("\u016e+\3\2\2\2\u016f\u0170\7:\2\2\u0170\u0171\7<\2\2")
        buf.write("\u0171\u0175\5R*\2\u0172\u0173\7\67\2\2\u0173\u0174\7")
        buf.write("\u0089\2\2\u0174\u0176\7\u00b1\2\2\u0175\u0172\3\2\2\2")
        buf.write("\u0175\u0176\3\2\2\2\u0176\u017b\3\2\2\2\u0177\u0178\7")
        buf.write("y\2\2\u0178\u0179\5~@\2\u0179\u017a\7z\2\2\u017a\u017c")
        buf.write("\3\2\2\2\u017b\u0177\3\2\2\2\u017b\u017c\3\2\2\2\u017c")
        buf.write("\u019c\3\2\2\2\u017d\u017e\7k\2\2\u017e\u017f\7y\2\2\u017f")
        buf.write("\u0184\5\u00a8U\2\u0180\u0181\7w\2\2\u0181\u0183\5\u00a8")
        buf.write("U\2\u0182\u0180\3\2\2\2\u0183\u0186\3\2\2\2\u0184\u0182")
        buf.write("\3\2\2\2\u0184\u0185\3\2\2\2\u0185\u0187\3\2\2\2\u0186")
        buf.write("\u0184\3\2\2\2\u0187\u0196\7z\2\2\u0188\u0189\7w\2\2\u0189")
        buf.write("\u018a\7y\2\2\u018a\u018f\5\u00a8U\2\u018b\u018c\7w\2")
        buf.write("\2\u018c\u018e\5\u00a8U\2\u018d\u018b\3\2\2\2\u018e\u0191")
        buf.write("\3\2\2\2\u018f\u018d\3\2\2\2\u018f\u0190\3\2\2\2\u0190")
        buf.write("\u0192\3\2\2\2\u0191\u018f\3\2\2\2\u0192\u0193\7z\2\2")
        buf.write("\u0193\u0195\3\2\2\2\u0194\u0188\3\2\2\2\u0195\u0198\3")
        buf.write("\2\2\2\u0196\u0194\3\2\2\2\u0196\u0197\3\2\2\2\u0197\u019d")
        buf.write("\3\2\2\2\u0198\u0196\3\2\2\2\u0199\u019a\7\61\2\2\u019a")
        buf.write("\u019d\5\\/\2\u019b\u019d\5\6\4\2\u019c\u017d\3\2\2\2")
        buf.write("\u019c\u0199\3\2\2\2\u019c\u019b\3\2\2\2\u019d-\3\2\2")
        buf.write("\2\u019e\u01a0\t\3\2\2\u019f\u01a1\7d\2\2\u01a0\u019f")
        buf.write("\3\2\2\2\u01a0\u01a1\3\2\2\2\u01a1\u01f6\3\2\2\2\u01a2")
        buf.write("\u01a6\7!\2\2\u01a3\u01a4\78\2\2\u01a4\u01a5\7J\2\2\u01a5")
        buf.write("\u01a7\7+\2\2\u01a6\u01a3\3\2\2\2\u01a6\u01a7\3\2\2\2")
        buf.write("\u01a7\u01a8\3\2\2\2\u01a8\u01f7\5X-\2\u01a9\u01ad\7b")
        buf.write("\2\2\u01aa\u01ab\78\2\2\u01ab\u01ac\7J\2\2\u01ac\u01ae")
        buf.write("\7+\2\2\u01ad\u01aa\3\2\2\2\u01ad\u01ae\3\2\2\2\u01ae")
        buf.write("\u01af\3\2\2\2\u01af\u01b3\5R*\2\u01b0\u01b1\7N\2\2\u01b1")
        buf.write("\u01b2\7\26\2\2\u01b2\u01b4\5V,\2\u01b3\u01b0\3\2\2\2")
        buf.write("\u01b3\u01b4\3\2\2\2\u01b4\u01db\3\2\2\2\u01b5\u01b6\7")
        buf.write("y\2\2\u01b6\u01b7\5v<\2\u01b7\u01b8\7z\2\2\u01b8\u01bb")
        buf.write("\5`\61\2\u01b9\u01ba\7\f\2\2\u01ba\u01bc\5\6\4\2\u01bb")
        buf.write("\u01b9\3\2\2\2\u01bb\u01bc\3\2\2\2\u01bc\u01bd\3\2\2\2")
        buf.write("\u01bd\u01be\7P\2\2\u01be\u01bf\7\22\2\2\u01bf\u01c0\7")
        buf.write("y\2\2\u01c0\u01c1\5f\64\2\u01c1\u01c5\7z\2\2\u01c2\u01c3")
        buf.write("\7S\2\2\u01c3\u01c4\7\22\2\2\u01c4\u01c6\5\u0090I\2\u01c5")
        buf.write("\u01c2\3\2\2\2\u01c5\u01c6\3\2\2\2\u01c6\u01ca\3\2\2\2")
        buf.write("\u01c7\u01c8\7[\2\2\u01c8\u01c9\7\22\2\2\u01c9\u01cb\5")
        buf.write("\u0090I\2\u01ca\u01c7\3\2\2\2\u01ca\u01cb\3\2\2\2\u01cb")
        buf.write("\u01cd\3\2\2\2\u01cc\u01ce\5j\66\2\u01cd\u01cc\3\2\2\2")
        buf.write("\u01cd\u01ce\3\2\2\2\u01ce\u01d0\3\2\2\2\u01cf\u01d1\5")
        buf.write("(\25\2\u01d0\u01cf\3\2\2\2\u01d0\u01d1\3\2\2\2\u01d1\u01dc")
        buf.write("\3\2\2\2\u01d2\u01d3\5`\61\2\u01d3\u01d9\7\f\2\2\u01d4")
        buf.write("\u01da\5\6\4\2\u01d5\u01d7\5R*\2\u01d6\u01d8\5`\61\2\u01d7")
        buf.write("\u01d6\3\2\2\2\u01d7\u01d8\3\2\2\2\u01d8\u01da\3\2\2\2")
        buf.write("\u01d9\u01d4\3\2\2\2\u01d9\u01d5\3\2\2\2\u01da\u01dc\3")
        buf.write("\2\2\2\u01db\u01b5\3\2\2\2\u01db\u01d2\3\2\2\2\u01dc\u01f7")
        buf.write("\3\2\2\2\u01dd\u01df\7F\2\2\u01de\u01dd\3\2\2\2\u01de")
        buf.write("\u01df\3\2\2\2\u01df\u01e0\3\2\2\2\u01e0\u01e4\7m\2\2")
        buf.write("\u01e1\u01e2\78\2\2\u01e2\u01e3\7J\2\2\u01e3\u01e5\7+")
        buf.write("\2\2\u01e4\u01e1\3\2\2\2\u01e4\u01e5\3\2\2\2\u01e5\u01e6")
        buf.write("\3\2\2\2\u01e6\u01eb\5R*\2\u01e7\u01e8\7y\2\2\u01e8\u01e9")
        buf.write("\5v<\2\u01e9\u01ea\7z\2\2\u01ea\u01ec\3\2\2\2\u01eb\u01e7")
        buf.write("\3\2\2\2\u01eb\u01ec\3\2\2\2\u01ec\u01ee\3\2\2\2\u01ed")
        buf.write("\u01ef\5`\61\2\u01ee\u01ed\3\2\2\2\u01ee\u01ef\3\2\2\2")
        buf.write("\u01ef\u01f1\3\2\2\2\u01f0\u01f2\7T\2\2\u01f1\u01f0\3")
        buf.write("\2\2\2\u01f1\u01f2\3\2\2\2\u01f2\u01f3\3\2\2\2\u01f3\u01f4")
        buf.write("\7\f\2\2\u01f4\u01f5\5\6\4\2\u01f5\u01f7\3\2\2\2\u01f6")
        buf.write("\u01a2\3\2\2\2\u01f6\u01a9\3\2\2\2\u01f6\u01de\3\2\2\2")
        buf.write("\u01f7/\3\2\2\2\u01f8\u01f9\7X\2\2\u01f9\u01fa\7b\2\2")
        buf.write("\u01fa\u01fb\5R*\2\u01fb\u01fc\7h\2\2\u01fc\u0204\5R*")
        buf.write("\2\u01fd\u01fe\7w\2\2\u01fe\u01ff\5R*\2\u01ff\u0200\7")
        buf.write("h\2\2\u0200\u0201\5R*\2\u0201\u0203\3\2\2\2\u0202\u01fd")
        buf.write("\3\2\2\2\u0203\u0206\3\2\2\2\u0204\u0202\3\2\2\2\u0204")
        buf.write("\u0205\3\2\2\2\u0205\u020a\3\2\2\2\u0206\u0204\3\2\2\2")
        buf.write("\u0207\u0208\7N\2\2\u0208\u0209\7\26\2\2\u0209\u020b\5")
        buf.write("V,\2\u020a\u0207\3\2\2\2\u020a\u020b\3\2\2\2\u020b\61")
        buf.write("\3\2\2\2\u020c\u0223\t\4\2\2\u020d\u0210\7!\2\2\u020e")
        buf.write("\u020f\78\2\2\u020f\u0211\7+\2\2\u0210\u020e\3\2\2\2\u0210")
        buf.write("\u0211\3\2\2\2\u0211\u0212\3\2\2\2\u0212\u0216\5X-\2\u0213")
        buf.write("\u0214\7N\2\2\u0214\u0215\7\26\2\2\u0215\u0217\5V,\2\u0216")
        buf.write("\u0213\3\2\2\2\u0216\u0217\3\2\2\2\u0217\u0224\3\2\2\2")
        buf.write("\u0218\u021b\7b\2\2\u0219\u021a\78\2\2\u021a\u021c\7+")
        buf.write("\2\2\u021b\u0219\3\2\2\2\u021b\u021c\3\2\2\2\u021c\u021d")
        buf.write("\3\2\2\2\u021d\u0221\5R*\2\u021e\u021f\7N\2\2\u021f\u0220")
        buf.write("\7\26\2\2\u0220\u0222\5V,\2\u0221\u021e\3\2\2\2\u0221")
        buf.write("\u0222\3\2\2\2\u0222\u0224\3\2\2\2\u0223\u020d\3\2\2\2")
        buf.write("\u0223\u0218\3\2\2\2\u0224\63\3\2\2\2\u0225\u0226\7\b")
        buf.write("\2\2\u0226\u0227\7b\2\2\u0227\u022b\5R*\2\u0228\u0229")
        buf.write("\7N\2\2\u0229\u022a\7\26\2\2\u022a\u022c\5V,\2\u022b\u0228")
        buf.write("\3\2\2\2\u022b\u022c\3\2\2\2\u022c\u022d\3\2\2\2\u022d")
        buf.write("\u0232\5\66\34\2\u022e\u022f\7w\2\2\u022f\u0231\5\66\34")
        buf.write("\2\u0230\u022e\3\2\2\2\u0231\u0234\3\2\2\2\u0232\u0230")
        buf.write("\3\2\2\2\u0232\u0233\3\2\2\2\u0233\65\3\2\2\2\u0234\u0232")
        buf.write("\3\2\2\2\u0235\u0236\7\4\2\2\u0236\u0237\7\27\2\2\u0237")
        buf.write("\u023a\5t;\2\u0238\u0239\7\5\2\2\u0239\u023b\5z>\2\u023a")
        buf.write("\u0238\3\2\2\2\u023a\u023b\3\2\2\2\u023b\u0255\3\2\2\2")
        buf.write("\u023c\u023d\7'\2\2\u023d\u023e\7\27\2\2\u023e\u0255")
        buf.write("\5z>\2\u023f\u0240\7H\2\2\u0240\u0241\7\27\2\2\u0241\u0255")
        buf.write("\5t;\2\u0242\u0243\7\20\2\2\u0243\u0244\7S\2\2\u0244\u0255")
        buf.write("\5T+\2\u0245\u0246\7$\2\2\u0246\u0247\7S\2\2\u0247\u0255")
        buf.write("\5T+\2\u0248\u0249\7'\2\2\u0249\u024a\7S\2\2\u024a\u0255")
        buf.write("\5T+\2\u024b\u024c\7,\2\2\u024c\u024d\7S\2\2\u024d\u024e")
        buf.write("\5T+\2\u024e\u024f\7/\2\2\u024f\u0250\7\u00b1\2\2\u0250")
        buf.write("\u0255\3\2\2\2\u0251\u0252\7\60\2\2\u0252\u0253\7S\2\2")
        buf.write("\u0253\u0255\5T+\2\u0254\u0235\3\2\2\2\u0254\u023c\3\2")
        buf.write("\2\2\u0254\u023f\3\2\2\2\u0254\u0242\3\2\2\2\u0254\u0245")
        buf.write("\3\2\2\2\u0254\u0248\3\2\2\2\u0254\u024b\3\2\2\2\u0254")
        buf.write("\u0251\3\2\2\2\u0255\67\3\2\2\2\u0256\u027a\5:\36\2\u0257")
        buf.write("\u0258\7\u00ae\2\2\u0258\u0259\7y\2\2\u0259\u025e\5\u00a0")
        buf.write("Q\2\u025a\u025b\7w\2\2\u025b\u025d\58\35\2\u025c\u025a")
        buf.write("\3\2\2\2\u025d\u0260\3\2\2\2\u025e\u025c\3\2\2\2\u025e")
        buf.write("\u025f\3\2\2\2\u025f\u0261\3\2\2\2\u0260\u025e\3\2\2\2")
        buf.write("\u0261\u0262\7z\2\2\u0262\u027a\3\2\2\2\u0263\u0264\7")
        buf.write("\u0092\2\2\u0264\u0265\7y\2\2\u0265\u0266\58\35\2\u0266")
        buf.write("\u0267\7z\2\2\u0267\u027a\3\2\2\2\u0268\u0269\7\u0093")
        buf.write("\2\2\u0269\u026a\7y\2\2\u026a\u026f\58\35\2\u026b\u026c")
        buf.write("\7w\2\2\u026c\u026e\58\35\2\u026d\u026b\3\2\2\2\u026e")
        buf.write("\u0271\3\2\2\2\u026f\u026d\3\2\2\2\u026f\u0270\3\2\2\2")
        buf.write("\u0270\u0272\3\2\2\2\u0271\u026f\3\2\2\2\u0272\u0273\7")
        buf.write("z\2\2\u0273\u027a\3\2\2\2\u0274\u0275\7\u0094\2\2\u0275")
        buf.write("\u0276\7y\2\2\u0276\u0277\58\35\2\u0277\u0278\7z\2\2\u0278")
        buf.write("\u027a\3\2\2\2\u0279\u0256\3\2\2\2\u0279\u0257\3\2\2\2")
        buf.write("\u0279\u0263\3\2\2\2\u0279\u0268\3\2\2\2\u0279\u0274\3")
        buf.write("\2\2\2\u027a9\3\2\2\2\u027b\u02ae\7\u0097\2\2\u027c\u02ae")
        buf.write("\7\u0098\2\2\u027d\u02ae\7\u0099\2\2\u027e\u02ae\7\u009a")
        buf.write("\2\2\u027f\u02ae\7\u009b\2\2\u0280\u02ae\7\u009c\2\2\u0281")
        buf.write("\u02ae\7\u009d\2\2\u0282\u02ae\7\u009e\2\2\u0283\u02ae")
        buf.write("\7\u0095\2\2\u0284\u02ae\7\u0096\2\2\u0285\u0286\7\u009f")
        buf.write("\2\2\u0286\u0287\7y\2\2\u0287\u028c\5<\37\2\u0288\u0289")
        buf.write("\7w\2\2\u0289\u028b\5<\37\2\u028a\u0288\3\2\2\2\u028b")
        buf.write("\u028e\3\2\2\2\u028c\u028a\3\2\2\2\u028c\u028d\3\2\2\2")
        buf.write("\u028d\u028f\3\2\2\2\u028e\u028c\3\2\2\2\u028f\u0290\7")
        buf.write("y\2\2\u0290\u02ae\3\2\2\2\u0291\u0292\7\u00a0\2\2\u0292")
        buf.write("\u0293\7y\2\2\u0293\u0298\5<\37\2\u0294\u0295\7w\2\2\u0295")
        buf.write("\u0297\5<\37\2\u0296\u0294\3\2\2\2\u0297\u029a\3\2\2\2")
        buf.write("\u0298\u0296\3\2\2\2\u0298\u0299\3\2\2\2\u0299\u029b\3")
        buf.write("\2\2\2\u029a\u0298\3\2\2\2\u029b\u029c\7y\2\2\u029c\u02ae")
        buf.write("\3\2\2\2\u029d\u02ae\7\u00a1\2\2\u029e\u02ae\7\u00a2\2")
        buf.write("\2\u029f\u02ae\7\u00a3\2\2\u02a0\u02ae\7\u00a4\2\2\u02a1")
        buf.write("\u02ae\7\u00a7\2\2\u02a2\u02ae\7\u00a8\2\2\u02a3\u02ae")
        buf.write("\7\u00a9\2\2\u02a4\u02ae\7\u00aa\2\2\u02a5\u02ae\7\u00ab")
        buf.write("\2\2\u02a6\u02ae\7\u00ac\2\2\u02a7\u02ae\7\u00ad\2\2\u02a8")
        buf.write("\u02ae\7\u00a6\2\2\u02a9\u02aa\7\u00a5\2\2\u02aa\u02ab")
        buf.write("\7y\2\2\u02ab\u02ac\7\u00b0\2\2\u02ac\u02ae\7y\2\2\u02ad")
        buf.write("\u027b\3\2\2\2\u02ad\u027c\3\2\2\2\u02ad\u027d\3\2\2\2")
        buf.write("\u02ad\u027e\3\2\2\2\u02ad\u027f\3\2\2\2\u02ad\u0280\3")
        buf.write("\2\2\2\u02ad\u0281\3\2\2\2\u02ad\u0282\3\2\2\2\u02ad\u0283")
        buf.write("\3\2\2\2\u02ad\u0284\3\2\2\2\u02ad\u0285\3\2\2\2\u02ad")
        buf.write("\u0291\3\2\2\2\u02ad\u029d\3\2\2\2\u02ad\u029e\3\2\2\2")
        buf.write("\u02ad\u029f\3\2\2\2\u02ad\u02a0\3\2\2\2\u02ad\u02a1\3")
        buf.write("\2\2\2\u02ad\u02a2\3\2\2\2\u02ad\u02a3\3\2\2\2\u02ad\u02a4")
        buf.write("\3\2\2\2\u02ad\u02a5\3\2\2\2\u02ad\u02a6\3\2\2\2\u02ad")
        buf.write("\u02a7\3\2\2\2\u02ad\u02a8\3\2\2\2\u02ad\u02a9\3\2\2\2")
        buf.write("\u02ae;\3\2\2\2\u02af\u02b0\7\u00b1\2\2\u02b0\u02b1\7")
        buf.write("\u0089\2\2\u02b1\u02b2\7\u00b0\2\2\u02b2=\3\2\2\2\u02b3")
        buf.write("\u02b4\7o\2\2\u02b4\u02b5\5X-\2\u02b5?\3\2\2\2\u02b6\u02b8")
        buf.write("\7^\2\2\u02b7\u02b9\7\63\2\2\u02b8\u02b7\3\2\2\2\u02b8")
        buf.write('\u02b9\3\2\2\2\u02b9\u02ba\3\2\2\2\u02ba\u02bb\5B"\2')
        buf.write("\u02bbA\3\2\2\2\u02bc\u02c1\5D#\2\u02bd\u02be\7w\2\2\u02be")
        buf.write("\u02c0\5D#\2\u02bf\u02bd\3\2\2\2\u02c0\u02c3\3\2\2\2\u02c1")
        buf.write("\u02bf\3\2\2\2\u02c1\u02c2\3\2\2\2\u02c2C\3\2\2\2\u02c3")
        buf.write("\u02c1\3\2\2\2\u02c4\u02c5\5\u00a2R\2\u02c5\u02c6\7\u0089")
        buf.write("\2\2\u02c6\u02c7\5\u00a8U\2\u02c7E\3\2\2\2\u02c8\u02c9")
        buf.write("\7@\2\2\u02c9\u02ca\7W\2\2\u02ca\u02cb\7s\2\2\u02cb\u02cc")
        buf.write("\5\u008eH\2\u02cc\u02cd\t\5\2\2\u02cdG\3\2\2\2\u02ce\u02cf")
        buf.write("\7O\2\2\u02cf\u02d0\7b\2\2\u02d0\u02d3\5R*\2\u02d1\u02d2")
        buf.write("\7S\2\2\u02d2\u02d4\7\u00b1\2\2\u02d3\u02d1\3\2\2\2\u02d3")
        buf.write("\u02d4\3\2\2\2\u02d4\u02d6\3\2\2\2\u02d5\u02d7\7-\2\2")
        buf.write("\u02d6\u02d5\3\2\2\2\u02d6\u02d7\3\2\2\2\u02d7I\3\2\2")
        buf.write("\2\u02d8\u02dd\7+\2\2\u02d9\u02dd\t\6\2\2\u02da\u02db")
        buf.write("\7`\2\2\u02db\u02dd\7\32\2\2\u02dc\u02d8\3\2\2\2\u02dc")
        buf.write("\u02d9\3\2\2\2\u02dc\u02da\3\2\2\2\u02dd\u02de\3\2\2\2")
        buf.write("\u02de\u02df\7b\2\2\u02df\u02e1\5R*\2\u02e0\u02e2\5^\60")
        buf.write("\2\u02e1\u02e0\3\2\2\2\u02e1\u02e2\3\2\2\2\u02e2\u02e5")
        buf.write("\3\2\2\2\u02e3\u02e4\7\61\2\2\u02e4\u02e6\5\\/\2\u02e5")
        buf.write("\u02e3\3\2\2\2\u02e5\u02e6\3\2\2\2\u02e6K\3\2\2\2\u02e7")
        buf.write('\u02f5\7`\2\2\u02e8\u02f6\7"\2\2\u02e9\u02ec\7c\2\2\u02ea')
        buf.write("\u02eb\7/\2\2\u02eb\u02ed\5X-\2\u02ec\u02ea\3\2\2\2\u02ec")
        buf.write("\u02ed\3\2\2\2\u02ed\u02f3\3\2\2\2\u02ee\u02f0\7J\2\2")
        buf.write("\u02ef\u02ee\3\2\2\2\u02ef\u02f0\3\2\2\2\u02f0\u02f1\3")
        buf.write("\2\2\2\u02f1\u02f2\7C\2\2\u02f2\u02f4\7\u00b1\2\2\u02f3")
        buf.write("\u02ef\3\2\2\2\u02f3\u02f4\3\2\2\2\u02f4\u02f6\3\2\2\2")
        buf.write("\u02f5\u02e8\3\2\2\2\u02f5\u02e9\3\2\2\2\u02f6\u02f8\3")
        buf.write("\2\2\2\u02f7\u02f9\5^\60\2\u02f8\u02f7\3\2\2\2\u02f8\u02f9")
        buf.write("\3\2\2\2\u02f9\u02fc\3\2\2\2\u02fa\u02fb\7\61\2\2\u02fb")
        buf.write("\u02fd\5\\/\2\u02fc\u02fa\3\2\2\2\u02fc\u02fd\3\2\2\2")
        buf.write("\u02fdM\3\2\2\2\u02fe\u02ff\7`\2\2\u02ff\u0301\7V\2\2")
        buf.write("\u0300\u0302\5^\60\2\u0301\u0300\3\2\2\2\u0301\u0302\3")
        buf.write("\2\2\2\u0302\u0305\3\2\2\2\u0303\u0304\7\61\2\2\u0304")
        buf.write("\u0306\5\\/\2\u0305\u0303\3\2\2\2\u0305\u0306\3\2\2\2")
        buf.write("\u0306O\3\2\2\2\u0307\u0308\7\25\2\2\u0308\u0309\7b\2")
        buf.write("\2\u0309\u030a\5R*\2\u030aQ\3\2\2\2\u030b\u030c\5X-\2")
        buf.write("\u030c\u030d\7\u0084\2\2\u030d\u030f\3\2\2\2\u030e\u030b")
        buf.write("\3\2\2\2\u030e\u030f\3\2\2\2\u030f\u0310\3\2\2\2\u0310")
        buf.write("\u0311\5Z.\2\u0311S\3\2\2\2\u0312\u0315\5\u00a2R\2\u0313")
        buf.write("\u0315\7\u00b1\2\2\u0314\u0312\3\2\2\2\u0314\u0313\3\2")
        buf.write("\2\2\u0315U\3\2\2\2\u0316\u0319\5\u00a2R\2\u0317\u0319")
        buf.write("\7\u00b1\2\2\u0318\u0316\3\2\2\2\u0318\u0317\3\2\2\2\u0319")
        buf.write("W\3\2\2\2\u031a\u031b\5\u00a2R\2\u031bY\3\2\2\2\u031c")
        buf.write("\u031d\5\u00a2R\2\u031d[\3\2\2\2\u031e\u031f\5\u00a2R")
        buf.write("\2\u031f]\3\2\2\2\u0320\u0321\7<\2\2\u0321\u0322\7R\2")
        buf.write("\2\u0322\u0323\7\u00b1\2\2\u0323_\3\2\2\2\u0324\u0325")
        buf.write("\7*\2\2\u0325\u0326\7\u0089\2\2\u0326\u0327\5b\62\2\u0327")
        buf.write("a\3\2\2\2\u0328\u032b\5d\63\2\u0329\u032b\5\u00a2R\2\u032a")
        buf.write("\u0328\3\2\2\2\u032a\u0329\3\2\2\2\u032bc\3\2\2\2\u032c")
        buf.write("\u032f\5\u009aN\2\u032d\u032f\5n8\2\u032e\u032c\3\2\2")
        buf.write("\2\u032e\u032d\3\2\2\2\u032fe\3\2\2\2\u0330\u0335\5h\65")
        buf.write("\2\u0331\u0332\7w\2\2\u0332\u0334\5h\65\2\u0333\u0331")
        buf.write("\3\2\2\2\u0334\u0337\3\2\2\2\u0335\u0333\3\2\2\2\u0335")
        buf.write("\u0336\3\2\2\2\u0336g\3\2\2\2\u0337\u0335\3\2\2\2\u0338")
        buf.write("\u033a\5\u008eH\2\u0339\u033b\t\7\2\2\u033a\u0339\3\2")
        buf.write("\2\2\u033a\u033b\3\2\2\2\u033b\u033e\3\2\2\2\u033c\u033d")
        buf.write("\7L\2\2\u033d\u033f\t\b\2\2\u033e\u033c\3\2\2\2\u033e")
        buf.write("\u033f\3\2\2\2\u033f\u0342\3\2\2\2\u0340\u0341\7\30\2")
        buf.write("\2\u0341\u0343\7\u00b1\2\2\u0342\u0340\3\2\2\2\u0342\u0343")
        buf.write("\3\2\2\2\u0343i\3\2\2\2\u0344\u0345\7i\2\2\u0345\u034a")
        buf.write("\5l\67\2\u0346\u0347\7w\2\2\u0347\u0349\5l\67\2\u0348")
        buf.write("\u0346\3\2\2\2\u0349\u034c\3\2\2\2\u034a\u0348\3\2\2\2")
        buf.write("\u034a\u034b\3\2\2\2\u034bk\3\2\2\2\u034c\u034a\3\2\2")
        buf.write("\2\u034d\u0355\5\u0090I\2\u034e\u0356\7\35\2\2\u034f\u0350")
        buf.write("\7h\2\2\u0350\u0351\7%\2\2\u0351\u0356\7\u00b1\2\2\u0352")
        buf.write("\u0353\7h\2\2\u0353\u0354\7l\2\2\u0354\u0356\7\u00b1\2")
        buf.write("\2\u0355\u034e\3\2\2\2\u0355\u034f\3\2\2\2\u0355\u0352")
        buf.write("\3\2\2\2\u0355\u0356\3\2\2\2\u0356m\3\2\2\2\u0357\u0358")
        buf.write("\5\u00a2R\2\u0358\u0359\7y\2\2\u0359\u035a\5p9\2\u035a")
        buf.write("\u035b\7z\2\2\u035bo\3\2\2\2\u035c\u0361\5r:\2\u035d\u035e")
        buf.write("\7w\2\2\u035e\u0360\5r:\2\u035f\u035d\3\2\2\2\u0360\u0363")
        buf.write("\3\2\2\2\u0361\u035f\3\2\2\2\u0361\u0362\3\2\2\2\u0362")
        buf.write("q\3\2\2\2\u0363\u0361\3\2\2\2\u0364\u0365\5\u00a2R\2\u0365")
        buf.write("\u0366\5|?\2\u0366s\3\2\2\2\u0367\u0368\5\u00a6T\2\u0368")
        buf.write("\u0369\5|?\2\u0369u\3\2\2\2\u036a\u036f\5x=\2\u036b\u036c")
        buf.write("\7w\2\2\u036c\u036e\5x=\2\u036d\u036b\3\2\2\2\u036e\u0371")
        buf.write("\3\2\2\2\u036f\u036d\3\2\2\2\u036f\u0370\3\2\2\2\u0370")
        buf.write("w\3\2\2\2\u0371\u036f\3\2\2\2\u0372\u0373\5z>\2\u0373")
        buf.write("\u0376\5|?\2\u0374\u0375\t\t\2\2\u0375\u0377\5\u0090I")
        buf.write("\2\u0376\u0374\3\2\2\2\u0376\u0377\3\2\2\2\u0377\u037a")
        buf.write("\3\2\2\2\u0378\u0379\7\31\2\2\u0379\u037b\5\u0090I\2\u037a")
        buf.write("\u0378\3\2\2\2\u037a\u037b\3\2\2\2\u037b\u037e\3\2\2\2")
        buf.write("\u037c\u037d\7i\2\2\u037d\u037f\5\u0090I\2\u037e\u037c")
        buf.write("\3\2\2\2\u037e\u037f\3\2\2\2\u037fy\3\2\2\2\u0380\u0381")
        buf.write("\5\u00a2R\2\u0381{\3\2\2\2\u0382\u0383\58\35\2\u0383}")
        buf.write("\3\2\2\2\u0384\u0389\5z>\2\u0385\u0386\7w\2\2\u0386\u0388")
        buf.write("\5z>\2\u0387\u0385\3\2\2\2\u0388\u038b\3\2\2\2\u0389\u0387")
        buf.write("\3\2\2\2\u0389\u038a\3\2\2\2\u038a\177\3\2\2\2\u038b\u0389")
        buf.write("\3\2\2\2\u038c\u0391\5\u0082B\2\u038d\u038e\7w\2\2\u038e")
        buf.write("\u0390\5\u0082B\2\u038f\u038d\3\2\2\2\u0390\u0393\3\2")
        buf.write("\2\2\u0391\u038f\3\2\2\2\u0391\u0392\3\2\2\2\u0392\u0081")
        buf.write("\3\2\2\2\u0393\u0391\3\2\2\2\u0394\u0396\5\u0090I\2\u0395")
        buf.write("\u0397\5\u0084C\2\u0396\u0395\3\2\2\2\u0396\u0397\3\2")
        buf.write("\2\2\u0397\u0083\3\2\2\2\u0398\u039a\7\f\2\2\u0399\u0398")
        buf.write("\3\2\2\2\u0399\u039a\3\2\2\2\u039a\u039b\3\2\2\2\u039b")
        buf.write("\u039c\5\u0088E\2\u039c\u0085\3\2\2\2\u039d\u039e\7\f")
        buf.write("\2\2\u039e\u039f\5\u0088E\2\u039f\u0087\3\2\2\2\u03a0")
        buf.write("\u03a1\5\u00a2R\2\u03a1\u0089\3\2\2\2\u03a2\u03a3\5\u009a")
        buf.write("N\2\u03a3\u008b\3\2\2\2\u03a4\u03a5\7y\2\2\u03a5\u03a6")
        buf.write("\5\b\5\2\u03a6\u03a7\7z\2\2\u03a7\u008d\3\2\2\2\u03a8")
        buf.write("\u03aa\5\u0090I\2\u03a9\u03ab\5\u0086D\2\u03aa\u03a9\3")
        buf.write("\2\2\2\u03aa\u03ab\3\2\2\2\u03ab\u008f\3\2\2\2\u03ac\u03ad")
        buf.write("\bI\1\2\u03ad\u03ae\7y\2\2\u03ae\u03af\5\u0090I\2\u03af")
        buf.write("\u03b0\7z\2\2\u03b0\u03fa\3\2\2\2\u03b1\u03fa\5\u009a")
        buf.write("N\2\u03b2\u03b4\7\23\2\2\u03b3\u03b5\5\u0090I\2\u03b4")
        buf.write("\u03b3\3\2\2\2\u03b4\u03b5\3\2\2\2\u03b5\u03b6\3\2\2\2")
        buf.write("\u03b6\u03b7\7r\2\2\u03b7\u03b8\5\u0090I\2\u03b8\u03b9")
        buf.write("\7f\2\2\u03b9\u03ba\5\u0090I\2\u03ba\u03c2\3\2\2\2\u03bb")
        buf.write("\u03bc\7r\2\2\u03bc\u03bd\5\u0090I\2\u03bd\u03be\7f\2")
        buf.write("\2\u03be\u03bf\5\u0090I\2\u03bf\u03c1\3\2\2\2\u03c0\u03bb")
        buf.write("\3\2\2\2\u03c1\u03c4\3\2\2\2\u03c2\u03c0\3\2\2\2\u03c2")
        buf.write("\u03c3\3\2\2\2\u03c3\u03c5\3\2\2\2\u03c4\u03c2\3\2\2\2")
        buf.write("\u03c5\u03c6\7(\2\2\u03c6\u03c7\5\u0090I\2\u03c7\u03c8")
        buf.write("\7)\2\2\u03c8\u03fa\3\2\2\2\u03c9\u03ca\7\u0086\2\2\u03ca")
        buf.write("\u03fa\5\u0090I\30\u03cb\u03cc\7\24\2\2\u03cc\u03cd\7")
        buf.write("y\2\2\u03cd\u03ce\5\u0090I\2\u03ce\u03cf\7\f\2\2\u03cf")
        buf.write("\u03d0\58\35\2\u03d0\u03d1\7z\2\2\u03d1\u03fa\3\2\2\2")
        buf.write("\u03d2\u03d3\7;\2\2\u03d3\u03d4\5\u0090I\2\u03d4\u03d5")
        buf.write("\5\u0092J\2\u03d5\u03fa\3\2\2\2\u03d6\u03d7\7J\2\2\u03d7")
        buf.write("\u03fa\5\u0090I\16\u03d8\u03d9\7y\2\2\u03d9\u03de\5\u00a2")
        buf.write("R\2\u03da\u03db\7w\2\2\u03db\u03dd\5\u00a2R\2\u03dc\u03da")
        buf.write("\3\2\2\2\u03dd\u03e0\3\2\2\2\u03de\u03dc\3\2\2\2\u03de")
        buf.write("\u03df\3\2\2\2\u03df\u03e1\3\2\2\2\u03e0\u03de\3\2\2\2")
        buf.write("\u03e1\u03e2\7z\2\2\u03e2\u03ec\3\2\2\2\u03e3\u03e8\5")
        buf.write("\u00a2R\2\u03e4\u03e5\7w\2\2\u03e5\u03e7\5\u00a2R\2\u03e6")
        buf.write("\u03e4\3\2\2\2\u03e7\u03ea\3\2\2\2\u03e8\u03e6\3\2\2\2")
        buf.write("\u03e8\u03e9\3\2\2\2\u03e9\u03ec\3\2\2\2\u03ea\u03e8\3")
        buf.write("\2\2\2\u03eb\u03d8\3\2\2\2\u03eb\u03e3\3\2\2\2\u03ec\u03ed")
        buf.write("\3\2\2\2\u03ed\u03ee\7{\2\2\u03ee\u03ef\5\u0090I\n\u03ef")
        buf.write("\u03fa\3\2\2\2\u03f0\u03fa\5\u008cG\2\u03f1\u03f2\7y\2")
        buf.write("\2\u03f2\u03f3\5\u0096L\2\u03f3\u03f4\7z\2\2\u03f4\u03fa")
        buf.write("\3\2\2\2\u03f5\u03fa\5\u0098M\2\u03f6\u03fa\5\u00a8U\2")
        buf.write("\u03f7\u03fa\5\u00a6T\2\u03f8\u03fa\7\177\2\2\u03f9\u03ac")
        buf.write("\3\2\2\2\u03f9\u03b1\3\2\2\2\u03f9\u03b2\3\2\2\2\u03f9")
        buf.write("\u03c9\3\2\2\2\u03f9\u03cb\3\2\2\2\u03f9\u03d2\3\2\2\2")
        buf.write("\u03f9\u03d6\3\2\2\2\u03f9\u03eb\3\2\2\2\u03f9\u03f0\3")
        buf.write("\2\2\2\u03f9\u03f1\3\2\2\2\u03f9\u03f5\3\2\2\2\u03f9\u03f6")
        buf.write("\3\2\2\2\u03f9\u03f7\3\2\2\2\u03f9\u03f8\3\2\2\2\u03fa")
        buf.write("\u0445\3\2\2\2\u03fb\u03fc\f\32\2\2\u03fc\u03fd\7\u0084")
        buf.write("\2\2\u03fd\u0444\5\u0090I\33\u03fe\u03ff\f\26\2\2\u03ff")
        buf.write("\u0400\t\n\2\2\u0400\u0444\5\u0090I\27\u0401\u0402\f\25")
        buf.write("\2\2\u0402\u0403\t\13\2\2\u0403\u0444\5\u0090I\26\u0404")
        buf.write("\u0405\f\24\2\2\u0405\u0406\7\u0081\2\2\u0406\u0444\5")
        buf.write("\u0090I\25\u0407\u0408\f\23\2\2\u0408\u0409\7\21\2\2\u0409")
        buf.write("\u040a\5\u0090I\2\u040a\u040b\7\t\2\2\u040b\u040c\5\u0090")
        buf.write("I\24\u040c\u0444\3\2\2\2\u040d\u0419\f\22\2\2\u040e\u041a")
        buf.write("\7\u0088\2\2\u040f\u041a\7\u0089\2\2\u0410\u041a\7\u008a")
        buf.write("\2\2\u0411\u041a\7\u008b\2\2\u0412\u041a\7\u008c\2\2\u0413")
        buf.write("\u041a\7\u008d\2\2\u0414\u041a\7|\2\2\u0415\u041a\7}\2")
        buf.write("\2\u0416\u041a\7C\2\2\u0417\u0418\7J\2\2\u0418\u041a\7")
        buf.write("C\2\2\u0419\u040e\3\2\2\2\u0419\u040f\3\2\2\2\u0419\u0410")
        buf.write("\3\2\2\2\u0419\u0411\3\2\2\2\u0419\u0412\3\2\2\2\u0419")
        buf.write("\u0413\3\2\2\2\u0419\u0414\3\2\2\2\u0419\u0415\3\2\2\2")
        buf.write("\u0419\u0416\3\2\2\2\u0419\u0417\3\2\2\2\u041a\u041b\3")
        buf.write("\2\2\2\u041b\u0444\5\u0090I\23\u041c\u0425\f\21\2\2\u041d")
        buf.write("\u0426\7=\2\2\u041e\u041f\7J\2\2\u041f\u0426\7=\2\2\u0420")
        buf.write("\u0421\7\63\2\2\u0421\u0426\7=\2\2\u0422\u0423\7\63\2")
        buf.write("\2\u0423\u0424\7J\2\2\u0424\u0426\7=\2\2\u0425\u041d\3")
        buf.write("\2\2\2\u0425\u041e\3\2\2\2\u0425\u0420\3\2\2\2\u0425\u0422")
        buf.write("\3\2\2\2\u0426\u0427\3\2\2\2\u0427\u0444\5\u0090I\22\u0428")
        buf.write("\u0429\f\r\2\2\u0429\u042a\7\t\2\2\u042a\u0444\5\u0090")
        buf.write("I\16\u042b\u042c\f\f\2\2\u042c\u042d\7Q\2\2\u042d\u0444")
        buf.write("\5\u0090I\r\u042e\u042f\f\13\2\2\u042f\u0430\7~\2\2\u0430")
        buf.write("\u0431\5\u0090I\2\u0431\u0432\7v\2\2\u0432\u0433\5\u0090")
        buf.write("I\f\u0433\u0444\3\2\2\2\u0434\u0435\f\31\2\2\u0435\u0436")
        buf.write("\7\u008e\2\2\u0436\u0437\5\u0090I\2\u0437\u0438\7\u008f")
        buf.write("\2\2\u0438\u0444\3\2\2\2\u0439\u043f\f\20\2\2\u043a\u043b")
        buf.write("\7>\2\2\u043b\u0440\7K\2\2\u043c\u043d\7>\2\2\u043d\u043e")
        buf.write("\7J\2\2\u043e\u0440\7K\2\2\u043f\u043a\3\2\2\2\u043f\u043c")
        buf.write("\3\2\2\2\u0440\u0444\3\2\2\2\u0441\u0442\f\3\2\2\u0442")
        buf.write("\u0444\5\u0086D\2\u0443\u03fb\3\2\2\2\u0443\u03fe\3\2")
        buf.write("\2\2\u0443\u0401\3\2\2\2\u0443\u0404\3\2\2\2\u0443\u0407")
        buf.write("\3\2\2\2\u0443\u040d\3\2\2\2\u0443\u041c\3\2\2\2\u0443")
        buf.write("\u0428\3\2\2\2\u0443\u042b\3\2\2\2\u0443\u042e\3\2\2\2")
        buf.write("\u0443\u0434\3\2\2\2\u0443\u0439\3\2\2\2\u0443\u0441\3")
        buf.write("\2\2\2\u0444\u0447\3\2\2\2\u0445\u0443\3\2\2\2\u0445\u0446")
        buf.write("\3\2\2\2\u0446\u0091\3\2\2\2\u0447\u0445\3\2\2\2\u0448")
        buf.write("\u0449\t\f\2\2\u0449\u0093\3\2\2\2\u044a\u044c\5\u0096")
        buf.write("L\2\u044b\u044a\3\2\2\2\u044b\u044c\3\2\2\2\u044c\u0095")
        buf.write("\3\2\2\2\u044d\u0452\5\u0090I\2\u044e\u044f\7w\2\2\u044f")
        buf.write("\u0451\5\u0090I\2\u0450\u044e\3\2\2\2\u0451\u0454\3\2")
        buf.write("\2\2\u0452\u0450\3\2\2\2\u0452\u0453\3\2\2\2\u0453\u0097")
        buf.write("\3\2\2\2\u0454\u0452\3\2\2\2\u0455\u0456\7\u008e\2\2\u0456")
        buf.write("\u0457\5\u0094K\2\u0457\u0458\7\u008f\2\2\u0458\u0099")
        buf.write("\3\2\2\2\u0459\u045b\5\u00a0Q\2\u045a\u045c\5\u009cO\2")
        buf.write("\u045b\u045a\3\2\2\2\u045b\u045c\3\2\2\2\u045c\u045d\3")
        buf.write("\2\2\2\u045d\u045e\5\u009eP\2\u045e\u009b\3\2\2\2\u045f")
        buf.write("\u0468\7y\2\2\u0460\u0465\5\u0090I\2\u0461\u0462\7w\2")
        buf.write("\2\u0462\u0464\5\u0090I\2\u0463\u0461\3\2\2\2\u0464\u0467")
        buf.write("\3\2\2\2\u0465\u0463\3\2\2\2\u0465\u0466\3\2\2\2\u0466")
        buf.write("\u0469\3\2\2\2\u0467\u0465\3\2\2\2\u0468\u0460\3\2\2\2")
        buf.write("\u0468\u0469\3\2\2\2\u0469\u046a\3\2\2\2\u046a\u046b\7")
        buf.write("z\2\2\u046b\u009d\3\2\2\2\u046c\u0475\7y\2\2\u046d\u0472")
        buf.write("\5\u0090I\2\u046e\u046f\7w\2\2\u046f\u0471\5\u0090I\2")
        buf.write("\u0470\u046e\3\2\2\2\u0471\u0474\3\2\2\2\u0472\u0470\3")
        buf.write("\2\2\2\u0472\u0473\3\2\2\2\u0473\u0476\3\2\2\2\u0474\u0472")
        buf.write("\3\2\2\2\u0475\u046d\3\2\2\2\u0475\u0476\3\2\2\2\u0476")
        buf.write("\u0477\3\2\2\2\u0477\u0478\7z\2\2\u0478\u009f\3\2\2\2")
        buf.write("\u0479\u047a\5\u00a2R\2\u047a\u00a1\3\2\2\2\u047b\u0480")
        buf.write("\7\u00b2\2\2\u047c\u0480\7\u00af\2\2\u047d\u0480\5:\36")
        buf.write("\2\u047e\u0480\5\u00a4S\2\u047f\u047b\3\2\2\2\u047f\u047c")
        buf.write("\3\2\2\2\u047f\u047d\3\2\2\2\u047f\u047e\3\2\2\2\u0480")
        buf.write("\u00a3\3\2\2\2\u0481\u0482\t\r\2\2\u0482\u00a5\3\2\2\2")
        buf.write("\u0483\u0484\5\u00a2R\2\u0484\u0485\7\u0084\2\2\u0485")
        buf.write("\u0486\5\u00a2R\2\u0486\u0489\3\2\2\2\u0487\u0489\5\u00a2")
        buf.write("R\2\u0488\u0483\3\2\2\2\u0488\u0487\3\2\2\2\u0489\u00a7")
        buf.write("\3\2\2\2\u048a\u048b\t\16\2\2\u048b\u00a9\3\2\2\2\u048c")
        buf.write("\u048d\7\u00b4\2\2\u048d\u048e\bV\1\2\u048e\u00ab\3\2")
        buf.write("\2\2\u0087\u00ae\u00c0\u00c8\u00cc\u00cf\u00d2\u00d6\u00d9")
        buf.write("\u00dc\u00df\u00e2\u00e5\u00e8\u00eb\u00ee\u00f1\u00f4")
        buf.write("\u00f7\u00fa\u0101\u0109\u010c\u010f\u0119\u011e\u0121")
        buf.write("\u0127\u012b\u012f\u0131\u013c\u013f\u0144\u0148\u0155")
        buf.write("\u0162\u0175\u017b\u0184\u018f\u0196\u019c\u01a0\u01a6")
        buf.write("\u01ad\u01b3\u01bb\u01c5\u01ca\u01cd\u01d0\u01d7\u01d9")
        buf.write("\u01db\u01de\u01e4\u01eb\u01ee\u01f1\u01f6\u0204\u020a")
        buf.write("\u0210\u0216\u021b\u0221\u0223\u022b\u0232\u023a\u0254")
        buf.write("\u025e\u026f\u0279\u028c\u0298\u02ad\u02b8\u02c1\u02d3")
        buf.write("\u02d6\u02dc\u02e1\u02e5\u02ec\u02ef\u02f3\u02f5\u02f8")
        buf.write("\u02fc\u0301\u0305\u030e\u0314\u0318\u032a\u032e\u0335")
        buf.write("\u033a\u033e\u0342\u034a\u0355\u0361\u036f\u0376\u037a")
        buf.write("\u037e\u0389\u0391\u0396\u0399\u03aa\u03b4\u03c2\u03de")
        buf.write("\u03e8\u03eb\u03f9\u0419\u0425\u043f\u0443\u0445\u044b")
        buf.write("\u0452\u045b\u0465\u0468\u0472\u0475\u047f\u0488")
        return buf.getvalue()


class ClickHouseParser(Parser):

    grammarFileName = "ClickHouseParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]

    sharedContextCache = PredictionContextCache()

    literalNames = [
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "':'",
        "','",
        "';'",
        "'('",
        "')'",
        "'->'",
        "'<'",
        "'>'",
        "'?'",
        "'*'",
        "'+'",
        "'||'",
        "'|'",
        "'$'",
        "'.'",
        "'%'",
        "'-'",
        "'/'",
        "'=='",
        "'='",
        "'!='",
        "'<>'",
        "'<='",
        "'>='",
        "'['",
        "']'",
        "'{'",
        "'}'",
        "'Array'",
        "'Tuple'",
        "'Nullable'",
        "'Float32'",
        "'Float64'",
        "'UInt8'",
        "'UInt16'",
        "'UInt32'",
        "'UInt64'",
        "'Int8'",
        "'Int16'",
        "'Int32'",
        "'Int64'",
        "'Enum8'",
        "'Enum16'",
        "'UUID'",
        "'Date'",
        "'DateTime'",
        "'String'",
        "'FixedString'",
        "'Null'",
        "'IntervalYear'",
        "'IntervalMonth'",
        "'IntervalWeek'",
        "'IntervalDay'",
        "'IntervalHour'",
        "'IntervalMinute'",
        "'IntervalSecond'",
        "'AggregateFunction'",
    ]

    symbolicNames = [
        "<INVALID>",
        "LINE_COMMENT",
        "K_ADD",
        "K_AFTER",
        "K_ALL",
        "K_ALIAS",
        "K_ALTER",
        "K_AND",
        "K_ANY",
        "K_ARRAY",
        "K_AS",
        "K_ASCENDING",
        "K_ASC",
        "K_ASYNC",
        "K_ATTACH",
        "K_BETWEEN",
        "K_BY",
        "K_CASE",
        "K_CAST",
        "K_CHECK",
        "K_CLUSTER",
        "K_COLUMN",
        "K_COLLATE",
        "K_CODEC",
        "K_CREATE",
        "K_CROSS",
        "K_DAY",
        "K_DELETE",
        "K_DESCRIBE",
        "K_DESCENDING",
        "K_DESC",
        "K_DATABASE",
        "K_DATABASES",
        "K_DEFAULT",
        "K_DETACH",
        "K_DISK",
        "K_DISTINCT",
        "K_DROP",
        "K_ELSE",
        "K_END",
        "K_ENGINE",
        "K_EXISTS",
        "K_FETCH",
        "K_FINAL",
        "K_FIRST",
        "K_FROM",
        "K_FREEZE",
        "K_FORMAT",
        "K_FULL",
        "K_GLOBAL",
        "K_GROUP",
        "K_HAVING",
        "K_HOUR",
        "K_ID",
        "K_IF",
        "K_INNER",
        "K_INSERT",
        "K_INTERVAL",
        "K_INTO",
        "K_IN",
        "K_IS",
        "K_JOIN",
        "K_KILL",
        "K_LAST",
        "K_LEFT",
        "K_LIKE",
        "K_LIMIT",
        "K_MAIN",
        "K_MATERIALIZED",
        "K_MINUTE",
        "K_MODIFY",
        "K_MONTH",
        "K_NOT",
        "K_NULL",
        "K_NULLS",
        "K_OFFSET",
        "K_ON",
        "K_OPTIMIZE",
        "K_ORDER",
        "K_OR",
        "K_OUTFILE",
        "K_PARTITION",
        "K_POPULATE",
        "K_PREWHERE",
        "K_PROCESSLIST",
        "K_QUERY",
        "K_RENAME",
        "K_RETURN",
        "K_RIGHT",
        "K_SAMPLE",
        "K_SECOND",
        "K_SELECT",
        "K_SET",
        "K_SETTINGS",
        "K_SHOW",
        "K_SYNC",
        "K_TABLE",
        "K_TABLES",
        "K_TEMPORARY",
        "K_TEST",
        "K_THEN",
        "K_TOTALS",
        "K_TO",
        "K_TTL",
        "K_OUTER",
        "K_VALUES",
        "K_VOLUME",
        "K_VIEW",
        "K_UNION",
        "K_USE",
        "K_USING",
        "K_WEEK",
        "K_WHEN",
        "K_WHERE",
        "K_WITH",
        "K_YEAR",
        "COLON",
        "COMMA",
        "SEMI",
        "LPAREN",
        "RPAREN",
        "RARROW",
        "LT",
        "GT",
        "QUESTION",
        "STAR",
        "PLUS",
        "CONCAT",
        "OR",
        "DOLLAR",
        "DOT",
        "PERCENT",
        "MINUS",
        "DIVIDE",
        "EQUALS",
        "ASSIGN",
        "NOT_EQUALS",
        "NOT_EQUALS2",
        "LE",
        "GE",
        "LBRAKET",
        "RBRAKET",
        "LCURLY",
        "RCURLY",
        "T_ARRAY",
        "T_TUPLE",
        "T_NULLABLE",
        "T_FLOAT32",
        "T_FLOAT64",
        "T_UINT8",
        "T_UINT16",
        "T_UINT32",
        "T_UINT64",
        "T_INT8",
        "T_INT16",
        "T_INT32",
        "T_INT64",
        "T_ENUM8",
        "T_ENUM16",
        "T_UUID",
        "T_DATE",
        "T_DATETIME",
        "T_STRING",
        "T_FIXEDSTRING",
        "T_NULL",
        "T_INTERVAL_YEAR",
        "T_INTERVAL_MONTH",
        "T_INTERVAL_WEEK",
        "T_INTERVAL_DAY",
        "T_INTERVAL_HOUR",
        "T_INTERVAL_MINUTE",
        "T_INTERVAL_SECOND",
        "T_AGGREGATE_FUNCTION",
        "IDENTIFIER",
        "NUMERIC_LITERAL",
        "STRING_LITERAL",
        "QUOTED_LITERAL",
        "SPACES",
        "UNEXPECTED_CHAR",
    ]

    RULE_parse = 0
    RULE_query = 1
    RULE_select_query = 2
    RULE_select_query_main = 3
    RULE_select_with_step = 4
    RULE_select_select_step = 5
    RULE_select_from_step = 6
    RULE_select_array_join_step = 7
    RULE_select_sample_step = 8
    RULE_sample_ratio = 9
    RULE_select_join_step = 10
    RULE_select_join_right_part = 11
    RULE_select_prewhere_step = 12
    RULE_select_where_step = 13
    RULE_select_groupby_step = 14
    RULE_select_having_step = 15
    RULE_select_orderby_step = 16
    RULE_select_limit_step = 17
    RULE_select_limitby_step = 18
    RULE_settings_step = 19
    RULE_select_format_step = 20
    RULE_insert_query = 21
    RULE_create_query = 22
    RULE_rename_query = 23
    RULE_drop_query = 24
    RULE_alter_query = 25
    RULE_alter_query_element = 26
    RULE_clickhouse_type = 27
    RULE_simple_type = 28
    RULE_enum_entry = 29
    RULE_use_query = 30
    RULE_set_query = 31
    RULE_assignment_list = 32
    RULE_assignment = 33
    RULE_kill_query_query = 34
    RULE_optimize_query = 35
    RULE_table_properties_query = 36
    RULE_show_tables_query = 37
    RULE_show_processlist_query = 38
    RULE_check_query = 39
    RULE_full_table_name = 40
    RULE_partition_name = 41
    RULE_cluster_name = 42
    RULE_database_name = 43
    RULE_table_name = 44
    RULE_format_name = 45
    RULE_query_outfile_step = 46
    RULE_engine = 47
    RULE_identifier_with_optional_parameters = 48
    RULE_identifier_with_parameters = 49
    RULE_order_by_expression_list = 50
    RULE_order_by_element = 51
    RULE_table_ttl_list = 52
    RULE_table_ttl_declaration = 53
    RULE_nested_table = 54
    RULE_name_type_pair_list = 55
    RULE_name_type_pair = 56
    RULE_compound_name_type_pair = 57
    RULE_column_declaration_list = 58
    RULE_column_declaration = 59
    RULE_column_name = 60
    RULE_column_type = 61
    RULE_column_name_list = 62
    RULE_select_expr_list = 63
    RULE_select_expr = 64
    RULE_select_alias = 65
    RULE_alias = 66
    RULE_alias_name = 67
    RULE_table_function = 68
    RULE_subquery = 69
    RULE_expression_with_optional_alias = 70
    RULE_expr = 71
    RULE_interval_unit = 72
    RULE_expression_list = 73
    RULE_not_empty_expression_list = 74
    RULE_array = 75
    RULE_function = 76
    RULE_function_parameters = 77
    RULE_function_arguments = 78
    RULE_function_name = 79
    RULE_identifier = 80
    RULE_keyword = 81
    RULE_compound_identifier = 82
    RULE_literal = 83
    RULE_err = 84

    ruleNames = [
        "parse",
        "query",
        "select_query",
        "select_query_main",
        "select_with_step",
        "select_select_step",
        "select_from_step",
        "select_array_join_step",
        "select_sample_step",
        "sample_ratio",
        "select_join_step",
        "select_join_right_part",
        "select_prewhere_step",
        "select_where_step",
        "select_groupby_step",
        "select_having_step",
        "select_orderby_step",
        "select_limit_step",
        "select_limitby_step",
        "settings_step",
        "select_format_step",
        "insert_query",
        "create_query",
        "rename_query",
        "drop_query",
        "alter_query",
        "alter_query_element",
        "clickhouse_type",
        "simple_type",
        "enum_entry",
        "use_query",
        "set_query",
        "assignment_list",
        "assignment",
        "kill_query_query",
        "optimize_query",
        "table_properties_query",
        "show_tables_query",
        "show_processlist_query",
        "check_query",
        "full_table_name",
        "partition_name",
        "cluster_name",
        "database_name",
        "table_name",
        "format_name",
        "query_outfile_step",
        "engine",
        "identifier_with_optional_parameters",
        "identifier_with_parameters",
        "order_by_expression_list",
        "order_by_element",
        "table_ttl_list",
        "table_ttl_declaration",
        "nested_table",
        "name_type_pair_list",
        "name_type_pair",
        "compound_name_type_pair",
        "column_declaration_list",
        "column_declaration",
        "column_name",
        "column_type",
        "column_name_list",
        "select_expr_list",
        "select_expr",
        "select_alias",
        "alias",
        "alias_name",
        "table_function",
        "subquery",
        "expression_with_optional_alias",
        "expr",
        "interval_unit",
        "expression_list",
        "not_empty_expression_list",
        "array",
        "function",
        "function_parameters",
        "function_arguments",
        "function_name",
        "identifier",
        "keyword",
        "compound_identifier",
        "literal",
        "err",
    ]

    EOF = Token.EOF
    LINE_COMMENT = 1
    K_ADD = 2
    K_AFTER = 3
    K_ALL = 4
    K_ALIAS = 5
    K_ALTER = 6
    K_AND = 7
    K_ANY = 8
    K_ARRAY = 9
    K_AS = 10
    K_ASCENDING = 11
    K_ASC = 12
    K_ASYNC = 13
    K_ATTACH = 14
    K_BETWEEN = 15
    K_BY = 16
    K_CASE = 17
    K_CAST = 18
    K_CHECK = 19
    K_CLUSTER = 20
    K_COLUMN = 21
    K_COLLATE = 22
    K_CODEC = 23
    K_CREATE = 24
    K_CROSS = 25
    K_DAY = 26
    K_DELETE = 27
    K_DESCRIBE = 28
    K_DESCENDING = 29
    K_DESC = 30
    K_DATABASE = 31
    K_DATABASES = 32
    K_DEFAULT = 33
    K_DETACH = 34
    K_DISK = 35
    K_DISTINCT = 36
    K_DROP = 37
    K_ELSE = 38
    K_END = 39
    K_ENGINE = 40
    K_EXISTS = 41
    K_FETCH = 42
    K_FINAL = 43
    K_FIRST = 44
    K_FROM = 45
    K_FREEZE = 46
    K_FORMAT = 47
    K_FULL = 48
    K_GLOBAL = 49
    K_GROUP = 50
    K_HAVING = 51
    K_HOUR = 52
    K_ID = 53
    K_IF = 54
    K_INNER = 55
    K_INSERT = 56
    K_INTERVAL = 57
    K_INTO = 58
    K_IN = 59
    K_IS = 60
    K_JOIN = 61
    K_KILL = 62
    K_LAST = 63
    K_LEFT = 64
    K_LIKE = 65
    K_LIMIT = 66
    K_MAIN = 67
    K_MATERIALIZED = 68
    K_MINUTE = 69
    K_MODIFY = 70
    K_MONTH = 71
    K_NOT = 72
    K_NULL = 73
    K_NULLS = 74
    K_OFFSET = 75
    K_ON = 76
    K_OPTIMIZE = 77
    K_ORDER = 78
    K_OR = 79
    K_OUTFILE = 80
    K_PARTITION = 81
    K_POPULATE = 82
    K_PREWHERE = 83
    K_PROCESSLIST = 84
    K_QUERY = 85
    K_RENAME = 86
    K_RETURN = 87
    K_RIGHT = 88
    K_SAMPLE = 89
    K_SECOND = 90
    K_SELECT = 91
    K_SET = 92
    K_SETTINGS = 93
    K_SHOW = 94
    K_SYNC = 95
    K_TABLE = 96
    K_TABLES = 97
    K_TEMPORARY = 98
    K_TEST = 99
    K_THEN = 100
    K_TOTALS = 101
    K_TO = 102
    K_TTL = 103
    K_OUTER = 104
    K_VALUES = 105
    K_VOLUME = 106
    K_VIEW = 107
    K_UNION = 108
    K_USE = 109
    K_USING = 110
    K_WEEK = 111
    K_WHEN = 112
    K_WHERE = 113
    K_WITH = 114
    K_YEAR = 115
    COLON = 116
    COMMA = 117
    SEMI = 118
    LPAREN = 119
    RPAREN = 120
    RARROW = 121
    LT = 122
    GT = 123
    QUESTION = 124
    STAR = 125
    PLUS = 126
    CONCAT = 127
    OR = 128
    DOLLAR = 129
    DOT = 130
    PERCENT = 131
    MINUS = 132
    DIVIDE = 133
    EQUALS = 134
    ASSIGN = 135
    NOT_EQUALS = 136
    NOT_EQUALS2 = 137
    LE = 138
    GE = 139
    LBRAKET = 140
    RBRAKET = 141
    LCURLY = 142
    RCURLY = 143
    T_ARRAY = 144
    T_TUPLE = 145
    T_NULLABLE = 146
    T_FLOAT32 = 147
    T_FLOAT64 = 148
    T_UINT8 = 149
    T_UINT16 = 150
    T_UINT32 = 151
    T_UINT64 = 152
    T_INT8 = 153
    T_INT16 = 154
    T_INT32 = 155
    T_INT64 = 156
    T_ENUM8 = 157
    T_ENUM16 = 158
    T_UUID = 159
    T_DATE = 160
    T_DATETIME = 161
    T_STRING = 162
    T_FIXEDSTRING = 163
    T_NULL = 164
    T_INTERVAL_YEAR = 165
    T_INTERVAL_MONTH = 166
    T_INTERVAL_WEEK = 167
    T_INTERVAL_DAY = 168
    T_INTERVAL_HOUR = 169
    T_INTERVAL_MINUTE = 170
    T_INTERVAL_SECOND = 171
    T_AGGREGATE_FUNCTION = 172
    IDENTIFIER = 173
    NUMERIC_LITERAL = 174
    STRING_LITERAL = 175
    QUOTED_LITERAL = 176
    SPACES = 177
    UNEXPECTED_CHAR = 178

    def __init__(self, input: TokenStream, output: TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(
            self, self.atn, self.decisionsToDFA, self.sharedContextCache
        )
        self._predicates = None

    class ParseContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(ClickHouseParser.EOF, 0)

        def query(self):
            return self.getTypedRuleContext(ClickHouseParser.QueryContext, 0)

        def err(self):
            return self.getTypedRuleContext(ClickHouseParser.ErrContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_parse

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterParse"):
                listener.enterParse(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitParse"):
                listener.exitParse(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitParse"):
                return visitor.visitParse(self)
            else:
                return visitor.visitChildren(self)

    def parse(self):

        localctx = ClickHouseParser.ParseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_parse)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 172
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [
                ClickHouseParser.K_ALTER,
                ClickHouseParser.K_ATTACH,
                ClickHouseParser.K_CHECK,
                ClickHouseParser.K_CREATE,
                ClickHouseParser.K_DESCRIBE,
                ClickHouseParser.K_DESC,
                ClickHouseParser.K_DETACH,
                ClickHouseParser.K_DROP,
                ClickHouseParser.K_EXISTS,
                ClickHouseParser.K_INSERT,
                ClickHouseParser.K_KILL,
                ClickHouseParser.K_OPTIMIZE,
                ClickHouseParser.K_RENAME,
                ClickHouseParser.K_SELECT,
                ClickHouseParser.K_SET,
                ClickHouseParser.K_SHOW,
                ClickHouseParser.K_USE,
                ClickHouseParser.K_WITH,
            ]:
                self.state = 170
                self.query()
                pass
            elif token in [ClickHouseParser.UNEXPECTED_CHAR]:
                self.state = 171
                self.err()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 174
            self.match(ClickHouseParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class QueryContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def show_tables_query(self):
            return self.getTypedRuleContext(ClickHouseParser.Show_tables_queryContext, 0)

        def select_query(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_queryContext, 0)

        def insert_query(self):
            return self.getTypedRuleContext(ClickHouseParser.Insert_queryContext, 0)

        def create_query(self):
            return self.getTypedRuleContext(ClickHouseParser.Create_queryContext, 0)

        def rename_query(self):
            return self.getTypedRuleContext(ClickHouseParser.Rename_queryContext, 0)

        def drop_query(self):
            return self.getTypedRuleContext(ClickHouseParser.Drop_queryContext, 0)

        def alter_query(self):
            return self.getTypedRuleContext(ClickHouseParser.Alter_queryContext, 0)

        def use_query(self):
            return self.getTypedRuleContext(ClickHouseParser.Use_queryContext, 0)

        def set_query(self):
            return self.getTypedRuleContext(ClickHouseParser.Set_queryContext, 0)

        def optimize_query(self):
            return self.getTypedRuleContext(ClickHouseParser.Optimize_queryContext, 0)

        def table_properties_query(self):
            return self.getTypedRuleContext(ClickHouseParser.Table_properties_queryContext, 0)

        def show_processlist_query(self):
            return self.getTypedRuleContext(ClickHouseParser.Show_processlist_queryContext, 0)

        def check_query(self):
            return self.getTypedRuleContext(ClickHouseParser.Check_queryContext, 0)

        def kill_query_query(self):
            return self.getTypedRuleContext(ClickHouseParser.Kill_query_queryContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_query

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterQuery"):
                listener.enterQuery(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitQuery"):
                listener.exitQuery(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitQuery"):
                return visitor.visitQuery(self)
            else:
                return visitor.visitChildren(self)

    def query(self):

        localctx = ClickHouseParser.QueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_query)
        try:
            self.state = 190
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 1, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 176
                self.show_tables_query()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 177
                self.select_query()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 178
                self.insert_query()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 179
                self.create_query()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 180
                self.rename_query()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 181
                self.drop_query()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 182
                self.alter_query()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 183
                self.use_query()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 184
                self.set_query()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 185
                self.optimize_query()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 186
                self.table_properties_query()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 187
                self.show_processlist_query()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 188
                self.check_query()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 189
                self.kill_query_query()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_queryContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_query_main(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.Select_query_mainContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.Select_query_mainContext, i)

        def K_UNION(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.K_UNION)
            else:
                return self.getToken(ClickHouseParser.K_UNION, i)

        def K_ALL(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.K_ALL)
            else:
                return self.getToken(ClickHouseParser.K_ALL, i)

        def query_outfile_step(self):
            return self.getTypedRuleContext(ClickHouseParser.Query_outfile_stepContext, 0)

        def select_format_step(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_format_stepContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_select_query

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelect_query"):
                listener.enterSelect_query(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelect_query"):
                listener.exitSelect_query(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSelect_query"):
                return visitor.visitSelect_query(self)
            else:
                return visitor.visitChildren(self)

    def select_query(self):

        localctx = ClickHouseParser.Select_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_select_query)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 192
            self.select_query_main()
            self.state = 198
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ClickHouseParser.K_UNION:
                self.state = 193
                self.match(ClickHouseParser.K_UNION)
                self.state = 194
                self.match(ClickHouseParser.K_ALL)
                self.state = 195
                self.select_query_main()
                self.state = 200
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 202
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_INTO:
                self.state = 201
                self.query_outfile_step()

            self.state = 205
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_FORMAT:
                self.state = 204
                self.select_format_step()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_query_mainContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_select_step(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_select_stepContext, 0)

        def select_with_step(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_with_stepContext, 0)

        def select_from_step(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_from_stepContext, 0)

        def K_FINAL(self):
            return self.getToken(ClickHouseParser.K_FINAL, 0)

        def select_sample_step(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_sample_stepContext, 0)

        def select_array_join_step(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_array_join_stepContext, 0)

        def select_join_step(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_join_stepContext, 0)

        def select_prewhere_step(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_prewhere_stepContext, 0)

        def select_where_step(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_where_stepContext, 0)

        def select_groupby_step(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_groupby_stepContext, 0)

        def select_having_step(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_having_stepContext, 0)

        def select_orderby_step(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_orderby_stepContext, 0)

        def select_limitby_step(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_limitby_stepContext, 0)

        def select_limit_step(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_limit_stepContext, 0)

        def settings_step(self):
            return self.getTypedRuleContext(ClickHouseParser.Settings_stepContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_select_query_main

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelect_query_main"):
                listener.enterSelect_query_main(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelect_query_main"):
                listener.exitSelect_query_main(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSelect_query_main"):
                return visitor.visitSelect_query_main(self)
            else:
                return visitor.visitChildren(self)

    def select_query_main(self):

        localctx = ClickHouseParser.Select_query_mainContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_select_query_main)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 208
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_WITH:
                self.state = 207
                self.select_with_step()

            self.state = 210
            self.select_select_step()
            self.state = 212
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_FROM:
                self.state = 211
                self.select_from_step()

            self.state = 215
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_FINAL:
                self.state = 214
                self.match(ClickHouseParser.K_FINAL)

            self.state = 218
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_SAMPLE:
                self.state = 217
                self.select_sample_step()

            self.state = 221
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_ARRAY or _la == ClickHouseParser.K_LEFT:
                self.state = 220
                self.select_array_join_step()

            self.state = 224
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((_la) & ~0x3F) == 0 and (
                (1 << _la)
                & (
                    (1 << ClickHouseParser.K_ALL)
                    | (1 << ClickHouseParser.K_ANY)
                    | (1 << ClickHouseParser.K_CROSS)
                    | (1 << ClickHouseParser.K_GLOBAL)
                )
            ) != 0:
                self.state = 223
                self.select_join_step()

            self.state = 227
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_PREWHERE:
                self.state = 226
                self.select_prewhere_step()

            self.state = 230
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_WHERE:
                self.state = 229
                self.select_where_step()

            self.state = 233
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_GROUP:
                self.state = 232
                self.select_groupby_step()

            self.state = 236
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_HAVING:
                self.state = 235
                self.select_having_step()

            self.state = 239
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 15, self._ctx)
            if la_ == 1:
                self.state = 238
                self.select_orderby_step()

            self.state = 242
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 16, self._ctx)
            if la_ == 1:
                self.state = 241
                self.select_limitby_step()

            self.state = 245
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_LIMIT:
                self.state = 244
                self.select_limit_step()

            self.state = 248
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_SETTINGS:
                self.state = 247
                self.settings_step()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_with_stepContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_WITH(self):
            return self.getToken(ClickHouseParser.K_WITH, 0)

        def select_expr_list(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_expr_listContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_select_with_step

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelect_with_step"):
                listener.enterSelect_with_step(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelect_with_step"):
                listener.exitSelect_with_step(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSelect_with_step"):
                return visitor.visitSelect_with_step(self)
            else:
                return visitor.visitChildren(self)

    def select_with_step(self):

        localctx = ClickHouseParser.Select_with_stepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_select_with_step)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 250
            self.match(ClickHouseParser.K_WITH)
            self.state = 251
            self.select_expr_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_select_stepContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_SELECT(self):
            return self.getToken(ClickHouseParser.K_SELECT, 0)

        def select_expr_list(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_expr_listContext, 0)

        def K_DISTINCT(self):
            return self.getToken(ClickHouseParser.K_DISTINCT, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_select_select_step

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelect_select_step"):
                listener.enterSelect_select_step(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelect_select_step"):
                listener.exitSelect_select_step(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSelect_select_step"):
                return visitor.visitSelect_select_step(self)
            else:
                return visitor.visitChildren(self)

    def select_select_step(self):

        localctx = ClickHouseParser.Select_select_stepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_select_select_step)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 253
            self.match(ClickHouseParser.K_SELECT)
            self.state = 255
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 19, self._ctx)
            if la_ == 1:
                self.state = 254
                self.match(ClickHouseParser.K_DISTINCT)

            self.state = 257
            self.select_expr_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_from_stepContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_FROM(self):
            return self.getToken(ClickHouseParser.K_FROM, 0)

        def full_table_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Full_table_nameContext, 0)

        def table_function(self):
            return self.getTypedRuleContext(ClickHouseParser.Table_functionContext, 0)

        def subquery(self):
            return self.getTypedRuleContext(ClickHouseParser.SubqueryContext, 0)

        def select_alias(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_aliasContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_select_from_step

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelect_from_step"):
                listener.enterSelect_from_step(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelect_from_step"):
                listener.exitSelect_from_step(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSelect_from_step"):
                return visitor.visitSelect_from_step(self)
            else:
                return visitor.visitChildren(self)

    def select_from_step(self):

        localctx = ClickHouseParser.Select_from_stepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_select_from_step)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 259
            self.match(ClickHouseParser.K_FROM)
            self.state = 263
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 20, self._ctx)
            if la_ == 1:
                self.state = 260
                self.full_table_name()
                pass

            elif la_ == 2:
                self.state = 261
                self.table_function()
                pass

            elif la_ == 3:
                self.state = 262
                self.subquery()
                pass

            self.state = 266
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 21, self._ctx)
            if la_ == 1:
                self.state = 265
                self.select_alias()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_array_join_stepContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_ARRAY(self):
            return self.getToken(ClickHouseParser.K_ARRAY, 0)

        def K_JOIN(self):
            return self.getToken(ClickHouseParser.K_JOIN, 0)

        def not_empty_expression_list(self):
            return self.getTypedRuleContext(ClickHouseParser.Not_empty_expression_listContext, 0)

        def K_LEFT(self):
            return self.getToken(ClickHouseParser.K_LEFT, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_select_array_join_step

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelect_array_join_step"):
                listener.enterSelect_array_join_step(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelect_array_join_step"):
                listener.exitSelect_array_join_step(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSelect_array_join_step"):
                return visitor.visitSelect_array_join_step(self)
            else:
                return visitor.visitChildren(self)

    def select_array_join_step(self):

        localctx = ClickHouseParser.Select_array_join_stepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_select_array_join_step)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 269
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_LEFT:
                self.state = 268
                self.match(ClickHouseParser.K_LEFT)

            self.state = 271
            self.match(ClickHouseParser.K_ARRAY)
            self.state = 272
            self.match(ClickHouseParser.K_JOIN)
            self.state = 273
            self.not_empty_expression_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_sample_stepContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_SAMPLE(self):
            return self.getToken(ClickHouseParser.K_SAMPLE, 0)

        def sample_ratio(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.Sample_ratioContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.Sample_ratioContext, i)

        def K_OFFSET(self):
            return self.getToken(ClickHouseParser.K_OFFSET, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_select_sample_step

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelect_sample_step"):
                listener.enterSelect_sample_step(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelect_sample_step"):
                listener.exitSelect_sample_step(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSelect_sample_step"):
                return visitor.visitSelect_sample_step(self)
            else:
                return visitor.visitChildren(self)

    def select_sample_step(self):

        localctx = ClickHouseParser.Select_sample_stepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_select_sample_step)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 275
            self.match(ClickHouseParser.K_SAMPLE)
            self.state = 276
            self.sample_ratio()
            self.state = 279
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_OFFSET:
                self.state = 277
                self.match(ClickHouseParser.K_OFFSET)
                self.state = 278
                self.sample_ratio()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Sample_ratioContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERIC_LITERAL(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.NUMERIC_LITERAL)
            else:
                return self.getToken(ClickHouseParser.NUMERIC_LITERAL, i)

        def DIVIDE(self):
            return self.getToken(ClickHouseParser.DIVIDE, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_sample_ratio

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSample_ratio"):
                listener.enterSample_ratio(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSample_ratio"):
                listener.exitSample_ratio(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSample_ratio"):
                return visitor.visitSample_ratio(self)
            else:
                return visitor.visitChildren(self)

    def sample_ratio(self):

        localctx = ClickHouseParser.Sample_ratioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_sample_ratio)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 281
            self.match(ClickHouseParser.NUMERIC_LITERAL)
            self.state = 284
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.DIVIDE:
                self.state = 282
                self.match(ClickHouseParser.DIVIDE)
                self.state = 283
                self.match(ClickHouseParser.NUMERIC_LITERAL)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_join_stepContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_JOIN(self):
            return self.getToken(ClickHouseParser.K_JOIN, 0)

        def select_join_right_part(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_join_right_partContext, 0)

        def K_ANY(self):
            return self.getToken(ClickHouseParser.K_ANY, 0)

        def K_ALL(self):
            return self.getToken(ClickHouseParser.K_ALL, 0)

        def K_INNER(self):
            return self.getToken(ClickHouseParser.K_INNER, 0)

        def K_LEFT(self):
            return self.getToken(ClickHouseParser.K_LEFT, 0)

        def K_RIGHT(self):
            return self.getToken(ClickHouseParser.K_RIGHT, 0)

        def K_FULL(self):
            return self.getToken(ClickHouseParser.K_FULL, 0)

        def K_USING(self):
            return self.getToken(ClickHouseParser.K_USING, 0)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)

        def not_empty_expression_list(self):
            return self.getTypedRuleContext(ClickHouseParser.Not_empty_expression_listContext, 0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def K_GLOBAL(self):
            return self.getToken(ClickHouseParser.K_GLOBAL, 0)

        def K_OUTER(self):
            return self.getToken(ClickHouseParser.K_OUTER, 0)

        def K_CROSS(self):
            return self.getToken(ClickHouseParser.K_CROSS, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_select_join_step

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelect_join_step"):
                listener.enterSelect_join_step(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelect_join_step"):
                listener.exitSelect_join_step(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSelect_join_step"):
                return visitor.visitSelect_join_step(self)
            else:
                return visitor.visitChildren(self)

    def select_join_step(self):

        localctx = ClickHouseParser.Select_join_stepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_select_join_step)
        self._la = 0  # Token type
        try:
            self.state = 322
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 32, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 287
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == ClickHouseParser.K_GLOBAL:
                    self.state = 286
                    self.match(ClickHouseParser.K_GLOBAL)

                self.state = 289
                _la = self._input.LA(1)
                if not (_la == ClickHouseParser.K_ALL or _la == ClickHouseParser.K_ANY):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 303
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [ClickHouseParser.K_INNER]:
                    self.state = 290
                    self.match(ClickHouseParser.K_INNER)
                    pass
                elif token in [ClickHouseParser.K_LEFT]:
                    self.state = 291
                    self.match(ClickHouseParser.K_LEFT)
                    self.state = 293
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == ClickHouseParser.K_OUTER:
                        self.state = 292
                        self.match(ClickHouseParser.K_OUTER)

                    pass
                elif token in [ClickHouseParser.K_RIGHT]:
                    self.state = 295
                    self.match(ClickHouseParser.K_RIGHT)
                    self.state = 297
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == ClickHouseParser.K_OUTER:
                        self.state = 296
                        self.match(ClickHouseParser.K_OUTER)

                    pass
                elif token in [ClickHouseParser.K_FULL]:
                    self.state = 299
                    self.match(ClickHouseParser.K_FULL)
                    self.state = 301
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == ClickHouseParser.K_OUTER:
                        self.state = 300
                        self.match(ClickHouseParser.K_OUTER)

                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 305
                self.match(ClickHouseParser.K_JOIN)
                self.state = 306
                self.select_join_right_part()
                self.state = 314
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 30, self._ctx)
                if la_ == 1:
                    self.state = 307
                    self.match(ClickHouseParser.K_USING)
                    self.state = 308
                    self.match(ClickHouseParser.LPAREN)
                    self.state = 309
                    self.not_empty_expression_list()
                    self.state = 310
                    self.match(ClickHouseParser.RPAREN)
                    pass

                elif la_ == 2:
                    self.state = 312
                    self.match(ClickHouseParser.K_USING)
                    self.state = 313
                    self.not_empty_expression_list()
                    pass

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 317
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == ClickHouseParser.K_GLOBAL:
                    self.state = 316
                    self.match(ClickHouseParser.K_GLOBAL)

                self.state = 319
                self.match(ClickHouseParser.K_CROSS)
                self.state = 320
                self.match(ClickHouseParser.K_JOIN)
                self.state = 321
                self.select_join_right_part()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_join_right_partContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext, 0)

        def subquery(self):
            return self.getTypedRuleContext(ClickHouseParser.SubqueryContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_select_join_right_part

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelect_join_right_part"):
                listener.enterSelect_join_right_part(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelect_join_right_part"):
                listener.exitSelect_join_right_part(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSelect_join_right_part"):
                return visitor.visitSelect_join_right_part(self)
            else:
                return visitor.visitChildren(self)

    def select_join_right_part(self):

        localctx = ClickHouseParser.Select_join_right_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_select_join_right_part)
        try:
            self.state = 326
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [
                ClickHouseParser.K_ADD,
                ClickHouseParser.K_AFTER,
                ClickHouseParser.K_ALL,
                ClickHouseParser.K_ALIAS,
                ClickHouseParser.K_ALTER,
                ClickHouseParser.K_AND,
                ClickHouseParser.K_ANY,
                ClickHouseParser.K_ARRAY,
                ClickHouseParser.K_AS,
                ClickHouseParser.K_ASCENDING,
                ClickHouseParser.K_ASC,
                ClickHouseParser.K_ASYNC,
                ClickHouseParser.K_ATTACH,
                ClickHouseParser.K_BETWEEN,
                ClickHouseParser.K_BY,
                ClickHouseParser.K_CASE,
                ClickHouseParser.K_CHECK,
                ClickHouseParser.K_COLUMN,
                ClickHouseParser.K_COLLATE,
                ClickHouseParser.K_CREATE,
                ClickHouseParser.K_CROSS,
                ClickHouseParser.K_DESCRIBE,
                ClickHouseParser.K_DESCENDING,
                ClickHouseParser.K_DESC,
                ClickHouseParser.K_DATABASE,
                ClickHouseParser.K_DATABASES,
                ClickHouseParser.K_DEFAULT,
                ClickHouseParser.K_DETACH,
                ClickHouseParser.K_DISTINCT,
                ClickHouseParser.K_DROP,
                ClickHouseParser.K_ELSE,
                ClickHouseParser.K_END,
                ClickHouseParser.K_ENGINE,
                ClickHouseParser.K_EXISTS,
                ClickHouseParser.K_FINAL,
                ClickHouseParser.K_FIRST,
                ClickHouseParser.K_FROM,
                ClickHouseParser.K_FORMAT,
                ClickHouseParser.K_FULL,
                ClickHouseParser.K_GLOBAL,
                ClickHouseParser.K_GROUP,
                ClickHouseParser.K_HAVING,
                ClickHouseParser.K_ID,
                ClickHouseParser.K_IF,
                ClickHouseParser.K_INNER,
                ClickHouseParser.K_INSERT,
                ClickHouseParser.K_INTO,
                ClickHouseParser.K_IN,
                ClickHouseParser.K_IS,
                ClickHouseParser.K_JOIN,
                ClickHouseParser.K_KILL,
                ClickHouseParser.K_LAST,
                ClickHouseParser.K_LEFT,
                ClickHouseParser.K_LIKE,
                ClickHouseParser.K_LIMIT,
                ClickHouseParser.K_MAIN,
                ClickHouseParser.K_MATERIALIZED,
                ClickHouseParser.K_MODIFY,
                ClickHouseParser.K_NOT,
                ClickHouseParser.K_NULL,
                ClickHouseParser.K_NULLS,
                ClickHouseParser.K_OFFSET,
                ClickHouseParser.K_ON,
                ClickHouseParser.K_OPTIMIZE,
                ClickHouseParser.K_ORDER,
                ClickHouseParser.K_OR,
                ClickHouseParser.K_OUTFILE,
                ClickHouseParser.K_PARTITION,
                ClickHouseParser.K_POPULATE,
                ClickHouseParser.K_PREWHERE,
                ClickHouseParser.K_PROCESSLIST,
                ClickHouseParser.K_QUERY,
                ClickHouseParser.K_RENAME,
                ClickHouseParser.K_RETURN,
                ClickHouseParser.K_RIGHT,
                ClickHouseParser.K_SAMPLE,
                ClickHouseParser.K_SELECT,
                ClickHouseParser.K_SET,
                ClickHouseParser.K_SETTINGS,
                ClickHouseParser.K_SHOW,
                ClickHouseParser.K_SYNC,
                ClickHouseParser.K_TABLE,
                ClickHouseParser.K_TABLES,
                ClickHouseParser.K_TEMPORARY,
                ClickHouseParser.K_TEST,
                ClickHouseParser.K_THEN,
                ClickHouseParser.K_TOTALS,
                ClickHouseParser.K_TO,
                ClickHouseParser.K_OUTER,
                ClickHouseParser.K_VALUES,
                ClickHouseParser.K_VIEW,
                ClickHouseParser.K_UNION,
                ClickHouseParser.K_USE,
                ClickHouseParser.K_USING,
                ClickHouseParser.K_WHEN,
                ClickHouseParser.K_WHERE,
                ClickHouseParser.K_WITH,
                ClickHouseParser.T_FLOAT32,
                ClickHouseParser.T_FLOAT64,
                ClickHouseParser.T_UINT8,
                ClickHouseParser.T_UINT16,
                ClickHouseParser.T_UINT32,
                ClickHouseParser.T_UINT64,
                ClickHouseParser.T_INT8,
                ClickHouseParser.T_INT16,
                ClickHouseParser.T_INT32,
                ClickHouseParser.T_INT64,
                ClickHouseParser.T_ENUM8,
                ClickHouseParser.T_ENUM16,
                ClickHouseParser.T_UUID,
                ClickHouseParser.T_DATE,
                ClickHouseParser.T_DATETIME,
                ClickHouseParser.T_STRING,
                ClickHouseParser.T_FIXEDSTRING,
                ClickHouseParser.T_NULL,
                ClickHouseParser.T_INTERVAL_YEAR,
                ClickHouseParser.T_INTERVAL_MONTH,
                ClickHouseParser.T_INTERVAL_WEEK,
                ClickHouseParser.T_INTERVAL_DAY,
                ClickHouseParser.T_INTERVAL_HOUR,
                ClickHouseParser.T_INTERVAL_MINUTE,
                ClickHouseParser.T_INTERVAL_SECOND,
                ClickHouseParser.IDENTIFIER,
                ClickHouseParser.QUOTED_LITERAL,
            ]:
                self.enterOuterAlt(localctx, 1)
                self.state = 324
                self.identifier()
                pass
            elif token in [ClickHouseParser.LPAREN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 325
                self.subquery()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_prewhere_stepContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_PREWHERE(self):
            return self.getToken(ClickHouseParser.K_PREWHERE, 0)

        def expression_with_optional_alias(self):
            return self.getTypedRuleContext(
                ClickHouseParser.Expression_with_optional_aliasContext, 0
            )

        def getRuleIndex(self):
            return ClickHouseParser.RULE_select_prewhere_step

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelect_prewhere_step"):
                listener.enterSelect_prewhere_step(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelect_prewhere_step"):
                listener.exitSelect_prewhere_step(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSelect_prewhere_step"):
                return visitor.visitSelect_prewhere_step(self)
            else:
                return visitor.visitChildren(self)

    def select_prewhere_step(self):

        localctx = ClickHouseParser.Select_prewhere_stepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_select_prewhere_step)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 328
            self.match(ClickHouseParser.K_PREWHERE)
            self.state = 329
            self.expression_with_optional_alias()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_where_stepContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_WHERE(self):
            return self.getToken(ClickHouseParser.K_WHERE, 0)

        def expression_with_optional_alias(self):
            return self.getTypedRuleContext(
                ClickHouseParser.Expression_with_optional_aliasContext, 0
            )

        def getRuleIndex(self):
            return ClickHouseParser.RULE_select_where_step

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelect_where_step"):
                listener.enterSelect_where_step(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelect_where_step"):
                listener.exitSelect_where_step(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSelect_where_step"):
                return visitor.visitSelect_where_step(self)
            else:
                return visitor.visitChildren(self)

    def select_where_step(self):

        localctx = ClickHouseParser.Select_where_stepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_select_where_step)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 331
            self.match(ClickHouseParser.K_WHERE)
            self.state = 332
            self.expression_with_optional_alias()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_groupby_stepContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_GROUP(self):
            return self.getToken(ClickHouseParser.K_GROUP, 0)

        def K_BY(self):
            return self.getToken(ClickHouseParser.K_BY, 0)

        def not_empty_expression_list(self):
            return self.getTypedRuleContext(ClickHouseParser.Not_empty_expression_listContext, 0)

        def K_WITH(self):
            return self.getToken(ClickHouseParser.K_WITH, 0)

        def K_TOTALS(self):
            return self.getToken(ClickHouseParser.K_TOTALS, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_select_groupby_step

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelect_groupby_step"):
                listener.enterSelect_groupby_step(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelect_groupby_step"):
                listener.exitSelect_groupby_step(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSelect_groupby_step"):
                return visitor.visitSelect_groupby_step(self)
            else:
                return visitor.visitChildren(self)

    def select_groupby_step(self):

        localctx = ClickHouseParser.Select_groupby_stepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_select_groupby_step)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 334
            self.match(ClickHouseParser.K_GROUP)
            self.state = 335
            self.match(ClickHouseParser.K_BY)
            self.state = 336
            self.not_empty_expression_list()
            self.state = 339
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_WITH:
                self.state = 337
                self.match(ClickHouseParser.K_WITH)
                self.state = 338
                self.match(ClickHouseParser.K_TOTALS)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_having_stepContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_HAVING(self):
            return self.getToken(ClickHouseParser.K_HAVING, 0)

        def expression_with_optional_alias(self):
            return self.getTypedRuleContext(
                ClickHouseParser.Expression_with_optional_aliasContext, 0
            )

        def getRuleIndex(self):
            return ClickHouseParser.RULE_select_having_step

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelect_having_step"):
                listener.enterSelect_having_step(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelect_having_step"):
                listener.exitSelect_having_step(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSelect_having_step"):
                return visitor.visitSelect_having_step(self)
            else:
                return visitor.visitChildren(self)

    def select_having_step(self):

        localctx = ClickHouseParser.Select_having_stepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_select_having_step)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 341
            self.match(ClickHouseParser.K_HAVING)
            self.state = 342
            self.expression_with_optional_alias()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_orderby_stepContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_ORDER(self):
            return self.getToken(ClickHouseParser.K_ORDER, 0)

        def K_BY(self):
            return self.getToken(ClickHouseParser.K_BY, 0)

        def order_by_expression_list(self):
            return self.getTypedRuleContext(ClickHouseParser.Order_by_expression_listContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_select_orderby_step

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelect_orderby_step"):
                listener.enterSelect_orderby_step(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelect_orderby_step"):
                listener.exitSelect_orderby_step(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSelect_orderby_step"):
                return visitor.visitSelect_orderby_step(self)
            else:
                return visitor.visitChildren(self)

    def select_orderby_step(self):

        localctx = ClickHouseParser.Select_orderby_stepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_select_orderby_step)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 344
            self.match(ClickHouseParser.K_ORDER)
            self.state = 345
            self.match(ClickHouseParser.K_BY)
            self.state = 346
            self.order_by_expression_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_limit_stepContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_LIMIT(self):
            return self.getToken(ClickHouseParser.K_LIMIT, 0)

        def NUMERIC_LITERAL(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.NUMERIC_LITERAL)
            else:
                return self.getToken(ClickHouseParser.NUMERIC_LITERAL, i)

        def COMMA(self):
            return self.getToken(ClickHouseParser.COMMA, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_select_limit_step

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelect_limit_step"):
                listener.enterSelect_limit_step(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelect_limit_step"):
                listener.exitSelect_limit_step(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSelect_limit_step"):
                return visitor.visitSelect_limit_step(self)
            else:
                return visitor.visitChildren(self)

    def select_limit_step(self):

        localctx = ClickHouseParser.Select_limit_stepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_select_limit_step)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 348
            self.match(ClickHouseParser.K_LIMIT)
            self.state = 349
            self.match(ClickHouseParser.NUMERIC_LITERAL)
            self.state = 352
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.COMMA:
                self.state = 350
                self.match(ClickHouseParser.COMMA)
                self.state = 351
                self.match(ClickHouseParser.NUMERIC_LITERAL)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_limitby_stepContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_LIMIT(self):
            return self.getToken(ClickHouseParser.K_LIMIT, 0)

        def NUMERIC_LITERAL(self):
            return self.getToken(ClickHouseParser.NUMERIC_LITERAL, 0)

        def K_BY(self):
            return self.getToken(ClickHouseParser.K_BY, 0)

        def not_empty_expression_list(self):
            return self.getTypedRuleContext(ClickHouseParser.Not_empty_expression_listContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_select_limitby_step

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelect_limitby_step"):
                listener.enterSelect_limitby_step(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelect_limitby_step"):
                listener.exitSelect_limitby_step(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSelect_limitby_step"):
                return visitor.visitSelect_limitby_step(self)
            else:
                return visitor.visitChildren(self)

    def select_limitby_step(self):

        localctx = ClickHouseParser.Select_limitby_stepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_select_limitby_step)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 354
            self.match(ClickHouseParser.K_LIMIT)
            self.state = 355
            self.match(ClickHouseParser.NUMERIC_LITERAL)
            self.state = 356
            self.match(ClickHouseParser.K_BY)
            self.state = 357
            self.not_empty_expression_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Settings_stepContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_SETTINGS(self):
            return self.getToken(ClickHouseParser.K_SETTINGS, 0)

        def assignment_list(self):
            return self.getTypedRuleContext(ClickHouseParser.Assignment_listContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_settings_step

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSettings_step"):
                listener.enterSettings_step(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSettings_step"):
                listener.exitSettings_step(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSettings_step"):
                return visitor.visitSettings_step(self)
            else:
                return visitor.visitChildren(self)

    def settings_step(self):

        localctx = ClickHouseParser.Settings_stepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_settings_step)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 359
            self.match(ClickHouseParser.K_SETTINGS)
            self.state = 360
            self.assignment_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_format_stepContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_FORMAT(self):
            return self.getToken(ClickHouseParser.K_FORMAT, 0)

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_select_format_step

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelect_format_step"):
                listener.enterSelect_format_step(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelect_format_step"):
                listener.exitSelect_format_step(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSelect_format_step"):
                return visitor.visitSelect_format_step(self)
            else:
                return visitor.visitChildren(self)

    def select_format_step(self):

        localctx = ClickHouseParser.Select_format_stepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_select_format_step)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 362
            self.match(ClickHouseParser.K_FORMAT)
            self.state = 363
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Insert_queryContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_INSERT(self):
            return self.getToken(ClickHouseParser.K_INSERT, 0)

        def K_INTO(self):
            return self.getToken(ClickHouseParser.K_INTO, 0)

        def full_table_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Full_table_nameContext, 0)

        def K_VALUES(self):
            return self.getToken(ClickHouseParser.K_VALUES, 0)

        def LPAREN(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.LPAREN)
            else:
                return self.getToken(ClickHouseParser.LPAREN, i)

        def literal(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.LiteralContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.LiteralContext, i)

        def RPAREN(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.RPAREN)
            else:
                return self.getToken(ClickHouseParser.RPAREN, i)

        def K_FORMAT(self):
            return self.getToken(ClickHouseParser.K_FORMAT, 0)

        def format_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Format_nameContext, 0)

        def select_query(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_queryContext, 0)

        def K_ID(self):
            return self.getToken(ClickHouseParser.K_ID, 0)

        def ASSIGN(self):
            return self.getToken(ClickHouseParser.ASSIGN, 0)

        def STRING_LITERAL(self):
            return self.getToken(ClickHouseParser.STRING_LITERAL, 0)

        def column_name_list(self):
            return self.getTypedRuleContext(ClickHouseParser.Column_name_listContext, 0)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_insert_query

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInsert_query"):
                listener.enterInsert_query(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInsert_query"):
                listener.exitInsert_query(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInsert_query"):
                return visitor.visitInsert_query(self)
            else:
                return visitor.visitChildren(self)

    def insert_query(self):

        localctx = ClickHouseParser.Insert_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_insert_query)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 365
            self.match(ClickHouseParser.K_INSERT)
            self.state = 366
            self.match(ClickHouseParser.K_INTO)
            self.state = 367
            self.full_table_name()
            self.state = 371
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_ID:
                self.state = 368
                self.match(ClickHouseParser.K_ID)
                self.state = 369
                self.match(ClickHouseParser.ASSIGN)
                self.state = 370
                self.match(ClickHouseParser.STRING_LITERAL)

            self.state = 377
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.LPAREN:
                self.state = 373
                self.match(ClickHouseParser.LPAREN)
                self.state = 374
                self.column_name_list()
                self.state = 375
                self.match(ClickHouseParser.RPAREN)

            self.state = 410
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ClickHouseParser.K_VALUES]:
                self.state = 379
                self.match(ClickHouseParser.K_VALUES)
                self.state = 380
                self.match(ClickHouseParser.LPAREN)
                self.state = 381
                self.literal()
                self.state = 386
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == ClickHouseParser.COMMA:
                    self.state = 382
                    self.match(ClickHouseParser.COMMA)
                    self.state = 383
                    self.literal()
                    self.state = 388
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 389
                self.match(ClickHouseParser.RPAREN)
                self.state = 404
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == ClickHouseParser.COMMA:
                    self.state = 390
                    self.match(ClickHouseParser.COMMA)
                    self.state = 391
                    self.match(ClickHouseParser.LPAREN)
                    self.state = 392
                    self.literal()
                    self.state = 397
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la == ClickHouseParser.COMMA:
                        self.state = 393
                        self.match(ClickHouseParser.COMMA)
                        self.state = 394
                        self.literal()
                        self.state = 399
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 400
                    self.match(ClickHouseParser.RPAREN)
                    self.state = 406
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [ClickHouseParser.K_FORMAT]:
                self.state = 407
                self.match(ClickHouseParser.K_FORMAT)
                self.state = 408
                self.format_name()
                pass
            elif token in [ClickHouseParser.K_SELECT, ClickHouseParser.K_WITH]:
                self.state = 409
                self.select_query()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Create_queryContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.partitionExpr = None  # ExprContext
            self.sampleExpr = None  # ExprContext

        def K_CREATE(self):
            return self.getToken(ClickHouseParser.K_CREATE, 0)

        def K_ATTACH(self):
            return self.getToken(ClickHouseParser.K_ATTACH, 0)

        def K_DATABASE(self):
            return self.getToken(ClickHouseParser.K_DATABASE, 0)

        def database_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Database_nameContext, 0)

        def K_TABLE(self):
            return self.getToken(ClickHouseParser.K_TABLE, 0)

        def full_table_name(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.Full_table_nameContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.Full_table_nameContext, i)

        def K_VIEW(self):
            return self.getToken(ClickHouseParser.K_VIEW, 0)

        def K_AS(self):
            return self.getToken(ClickHouseParser.K_AS, 0)

        def select_query(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_queryContext, 0)

        def K_TEMPORARY(self):
            return self.getToken(ClickHouseParser.K_TEMPORARY, 0)

        def LPAREN(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.LPAREN)
            else:
                return self.getToken(ClickHouseParser.LPAREN, i)

        def column_declaration_list(self):
            return self.getTypedRuleContext(ClickHouseParser.Column_declaration_listContext, 0)

        def RPAREN(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.RPAREN)
            else:
                return self.getToken(ClickHouseParser.RPAREN, i)

        def engine(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.EngineContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.EngineContext, i)

        def K_ORDER(self):
            return self.getToken(ClickHouseParser.K_ORDER, 0)

        def K_BY(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.K_BY)
            else:
                return self.getToken(ClickHouseParser.K_BY, i)

        def order_by_expression_list(self):
            return self.getTypedRuleContext(ClickHouseParser.Order_by_expression_listContext, 0)

        def K_IF(self):
            return self.getToken(ClickHouseParser.K_IF, 0)

        def K_NOT(self):
            return self.getToken(ClickHouseParser.K_NOT, 0)

        def K_EXISTS(self):
            return self.getToken(ClickHouseParser.K_EXISTS, 0)

        def K_ON(self):
            return self.getToken(ClickHouseParser.K_ON, 0)

        def K_CLUSTER(self):
            return self.getToken(ClickHouseParser.K_CLUSTER, 0)

        def cluster_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Cluster_nameContext, 0)

        def K_MATERIALIZED(self):
            return self.getToken(ClickHouseParser.K_MATERIALIZED, 0)

        def K_POPULATE(self):
            return self.getToken(ClickHouseParser.K_POPULATE, 0)

        def K_PARTITION(self):
            return self.getToken(ClickHouseParser.K_PARTITION, 0)

        def K_SAMPLE(self):
            return self.getToken(ClickHouseParser.K_SAMPLE, 0)

        def table_ttl_list(self):
            return self.getTypedRuleContext(ClickHouseParser.Table_ttl_listContext, 0)

        def settings_step(self):
            return self.getTypedRuleContext(ClickHouseParser.Settings_stepContext, 0)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ExprContext, i)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_create_query

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCreate_query"):
                listener.enterCreate_query(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCreate_query"):
                listener.exitCreate_query(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCreate_query"):
                return visitor.visitCreate_query(self)
            else:
                return visitor.visitChildren(self)

    def create_query(self):

        localctx = ClickHouseParser.Create_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_create_query)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 412
            _la = self._input.LA(1)
            if not (_la == ClickHouseParser.K_ATTACH or _la == ClickHouseParser.K_CREATE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 414
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_TEMPORARY:
                self.state = 413
                self.match(ClickHouseParser.K_TEMPORARY)

            self.state = 500
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ClickHouseParser.K_DATABASE]:
                self.state = 416
                self.match(ClickHouseParser.K_DATABASE)
                self.state = 420
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 43, self._ctx)
                if la_ == 1:
                    self.state = 417
                    self.match(ClickHouseParser.K_IF)
                    self.state = 418
                    self.match(ClickHouseParser.K_NOT)
                    self.state = 419
                    self.match(ClickHouseParser.K_EXISTS)

                self.state = 422
                self.database_name()
                pass
            elif token in [ClickHouseParser.K_TABLE]:
                self.state = 423
                self.match(ClickHouseParser.K_TABLE)
                self.state = 427
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 44, self._ctx)
                if la_ == 1:
                    self.state = 424
                    self.match(ClickHouseParser.K_IF)
                    self.state = 425
                    self.match(ClickHouseParser.K_NOT)
                    self.state = 426
                    self.match(ClickHouseParser.K_EXISTS)

                self.state = 429
                self.full_table_name()
                self.state = 433
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == ClickHouseParser.K_ON:
                    self.state = 430
                    self.match(ClickHouseParser.K_ON)
                    self.state = 431
                    self.match(ClickHouseParser.K_CLUSTER)
                    self.state = 432
                    self.cluster_name()

                self.state = 473
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [ClickHouseParser.LPAREN]:
                    self.state = 435
                    self.match(ClickHouseParser.LPAREN)
                    self.state = 436
                    self.column_declaration_list()
                    self.state = 437
                    self.match(ClickHouseParser.RPAREN)
                    self.state = 438
                    self.engine()
                    self.state = 441
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == ClickHouseParser.K_AS:
                        self.state = 439
                        self.match(ClickHouseParser.K_AS)
                        self.state = 440
                        self.select_query()

                    self.state = 443
                    self.match(ClickHouseParser.K_ORDER)
                    self.state = 444
                    self.match(ClickHouseParser.K_BY)
                    self.state = 445
                    self.match(ClickHouseParser.LPAREN)
                    self.state = 446
                    self.order_by_expression_list()
                    self.state = 447
                    self.match(ClickHouseParser.RPAREN)
                    self.state = 451
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == ClickHouseParser.K_PARTITION:
                        self.state = 448
                        self.match(ClickHouseParser.K_PARTITION)
                        self.state = 449
                        self.match(ClickHouseParser.K_BY)
                        self.state = 450
                        localctx.partitionExpr = self.expr(0)

                    self.state = 456
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == ClickHouseParser.K_SAMPLE:
                        self.state = 453
                        self.match(ClickHouseParser.K_SAMPLE)
                        self.state = 454
                        self.match(ClickHouseParser.K_BY)
                        self.state = 455
                        localctx.sampleExpr = self.expr(0)

                    self.state = 459
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == ClickHouseParser.K_TTL:
                        self.state = 458
                        self.table_ttl_list()

                    self.state = 462
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == ClickHouseParser.K_SETTINGS:
                        self.state = 461
                        self.settings_step()

                    pass
                elif token in [ClickHouseParser.K_ENGINE]:
                    self.state = 464
                    self.engine()
                    self.state = 465
                    self.match(ClickHouseParser.K_AS)
                    self.state = 471
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 52, self._ctx)
                    if la_ == 1:
                        self.state = 466
                        self.select_query()
                        pass

                    elif la_ == 2:
                        self.state = 467
                        self.full_table_name()
                        self.state = 469
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la == ClickHouseParser.K_ENGINE:
                            self.state = 468
                            self.engine()

                        pass

                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [ClickHouseParser.K_MATERIALIZED, ClickHouseParser.K_VIEW]:
                self.state = 476
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == ClickHouseParser.K_MATERIALIZED:
                    self.state = 475
                    self.match(ClickHouseParser.K_MATERIALIZED)

                self.state = 478
                self.match(ClickHouseParser.K_VIEW)
                self.state = 482
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 55, self._ctx)
                if la_ == 1:
                    self.state = 479
                    self.match(ClickHouseParser.K_IF)
                    self.state = 480
                    self.match(ClickHouseParser.K_NOT)
                    self.state = 481
                    self.match(ClickHouseParser.K_EXISTS)

                self.state = 484
                self.full_table_name()
                self.state = 489
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == ClickHouseParser.LPAREN:
                    self.state = 485
                    self.match(ClickHouseParser.LPAREN)
                    self.state = 486
                    self.column_declaration_list()
                    self.state = 487
                    self.match(ClickHouseParser.RPAREN)

                self.state = 492
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == ClickHouseParser.K_ENGINE:
                    self.state = 491
                    self.engine()

                self.state = 495
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == ClickHouseParser.K_POPULATE:
                    self.state = 494
                    self.match(ClickHouseParser.K_POPULATE)

                self.state = 497
                self.match(ClickHouseParser.K_AS)
                self.state = 498
                self.select_query()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Rename_queryContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_RENAME(self):
            return self.getToken(ClickHouseParser.K_RENAME, 0)

        def K_TABLE(self):
            return self.getToken(ClickHouseParser.K_TABLE, 0)

        def full_table_name(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.Full_table_nameContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.Full_table_nameContext, i)

        def K_TO(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.K_TO)
            else:
                return self.getToken(ClickHouseParser.K_TO, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def K_ON(self):
            return self.getToken(ClickHouseParser.K_ON, 0)

        def K_CLUSTER(self):
            return self.getToken(ClickHouseParser.K_CLUSTER, 0)

        def cluster_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Cluster_nameContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_rename_query

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRename_query"):
                listener.enterRename_query(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRename_query"):
                listener.exitRename_query(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRename_query"):
                return visitor.visitRename_query(self)
            else:
                return visitor.visitChildren(self)

    def rename_query(self):

        localctx = ClickHouseParser.Rename_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_rename_query)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 502
            self.match(ClickHouseParser.K_RENAME)
            self.state = 503
            self.match(ClickHouseParser.K_TABLE)
            self.state = 504
            self.full_table_name()
            self.state = 505
            self.match(ClickHouseParser.K_TO)
            self.state = 506
            self.full_table_name()
            self.state = 514
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ClickHouseParser.COMMA:
                self.state = 507
                self.match(ClickHouseParser.COMMA)
                self.state = 508
                self.full_table_name()
                self.state = 509
                self.match(ClickHouseParser.K_TO)
                self.state = 510
                self.full_table_name()
                self.state = 516
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 520
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_ON:
                self.state = 517
                self.match(ClickHouseParser.K_ON)
                self.state = 518
                self.match(ClickHouseParser.K_CLUSTER)
                self.state = 519
                self.cluster_name()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Drop_queryContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_DROP(self):
            return self.getToken(ClickHouseParser.K_DROP, 0)

        def K_DETACH(self):
            return self.getToken(ClickHouseParser.K_DETACH, 0)

        def K_DATABASE(self):
            return self.getToken(ClickHouseParser.K_DATABASE, 0)

        def database_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Database_nameContext, 0)

        def K_TABLE(self):
            return self.getToken(ClickHouseParser.K_TABLE, 0)

        def full_table_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Full_table_nameContext, 0)

        def K_IF(self):
            return self.getToken(ClickHouseParser.K_IF, 0)

        def K_EXISTS(self):
            return self.getToken(ClickHouseParser.K_EXISTS, 0)

        def K_ON(self):
            return self.getToken(ClickHouseParser.K_ON, 0)

        def K_CLUSTER(self):
            return self.getToken(ClickHouseParser.K_CLUSTER, 0)

        def cluster_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Cluster_nameContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_drop_query

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDrop_query"):
                listener.enterDrop_query(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDrop_query"):
                listener.exitDrop_query(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDrop_query"):
                return visitor.visitDrop_query(self)
            else:
                return visitor.visitChildren(self)

    def drop_query(self):

        localctx = ClickHouseParser.Drop_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_drop_query)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 522
            _la = self._input.LA(1)
            if not (_la == ClickHouseParser.K_DETACH or _la == ClickHouseParser.K_DROP):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 545
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ClickHouseParser.K_DATABASE]:
                self.state = 523
                self.match(ClickHouseParser.K_DATABASE)
                self.state = 526
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 62, self._ctx)
                if la_ == 1:
                    self.state = 524
                    self.match(ClickHouseParser.K_IF)
                    self.state = 525
                    self.match(ClickHouseParser.K_EXISTS)

                self.state = 528
                self.database_name()
                self.state = 532
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == ClickHouseParser.K_ON:
                    self.state = 529
                    self.match(ClickHouseParser.K_ON)
                    self.state = 530
                    self.match(ClickHouseParser.K_CLUSTER)
                    self.state = 531
                    self.cluster_name()

                pass
            elif token in [ClickHouseParser.K_TABLE]:
                self.state = 534
                self.match(ClickHouseParser.K_TABLE)
                self.state = 537
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 64, self._ctx)
                if la_ == 1:
                    self.state = 535
                    self.match(ClickHouseParser.K_IF)
                    self.state = 536
                    self.match(ClickHouseParser.K_EXISTS)

                self.state = 539
                self.full_table_name()
                self.state = 543
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == ClickHouseParser.K_ON:
                    self.state = 540
                    self.match(ClickHouseParser.K_ON)
                    self.state = 541
                    self.match(ClickHouseParser.K_CLUSTER)
                    self.state = 542
                    self.cluster_name()

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Alter_queryContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_ALTER(self):
            return self.getToken(ClickHouseParser.K_ALTER, 0)

        def K_TABLE(self):
            return self.getToken(ClickHouseParser.K_TABLE, 0)

        def full_table_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Full_table_nameContext, 0)

        def alter_query_element(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.Alter_query_elementContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.Alter_query_elementContext, i)

        def K_ON(self):
            return self.getToken(ClickHouseParser.K_ON, 0)

        def K_CLUSTER(self):
            return self.getToken(ClickHouseParser.K_CLUSTER, 0)

        def cluster_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Cluster_nameContext, 0)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_alter_query

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAlter_query"):
                listener.enterAlter_query(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAlter_query"):
                listener.exitAlter_query(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAlter_query"):
                return visitor.visitAlter_query(self)
            else:
                return visitor.visitChildren(self)

    def alter_query(self):

        localctx = ClickHouseParser.Alter_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_alter_query)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 547
            self.match(ClickHouseParser.K_ALTER)
            self.state = 548
            self.match(ClickHouseParser.K_TABLE)
            self.state = 549
            self.full_table_name()
            self.state = 553
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_ON:
                self.state = 550
                self.match(ClickHouseParser.K_ON)
                self.state = 551
                self.match(ClickHouseParser.K_CLUSTER)
                self.state = 552
                self.cluster_name()

            self.state = 555
            self.alter_query_element()
            self.state = 560
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ClickHouseParser.COMMA:
                self.state = 556
                self.match(ClickHouseParser.COMMA)
                self.state = 557
                self.alter_query_element()
                self.state = 562
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Alter_query_elementContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_ADD(self):
            return self.getToken(ClickHouseParser.K_ADD, 0)

        def K_COLUMN(self):
            return self.getToken(ClickHouseParser.K_COLUMN, 0)

        def compound_name_type_pair(self):
            return self.getTypedRuleContext(ClickHouseParser.Compound_name_type_pairContext, 0)

        def K_AFTER(self):
            return self.getToken(ClickHouseParser.K_AFTER, 0)

        def column_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Column_nameContext, 0)

        def K_DROP(self):
            return self.getToken(ClickHouseParser.K_DROP, 0)

        def K_MODIFY(self):
            return self.getToken(ClickHouseParser.K_MODIFY, 0)

        def K_ATTACH(self):
            return self.getToken(ClickHouseParser.K_ATTACH, 0)

        def K_PARTITION(self):
            return self.getToken(ClickHouseParser.K_PARTITION, 0)

        def partition_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Partition_nameContext, 0)

        def K_DETACH(self):
            return self.getToken(ClickHouseParser.K_DETACH, 0)

        def K_FETCH(self):
            return self.getToken(ClickHouseParser.K_FETCH, 0)

        def K_FROM(self):
            return self.getToken(ClickHouseParser.K_FROM, 0)

        def STRING_LITERAL(self):
            return self.getToken(ClickHouseParser.STRING_LITERAL, 0)

        def K_FREEZE(self):
            return self.getToken(ClickHouseParser.K_FREEZE, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_alter_query_element

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAlter_query_element"):
                listener.enterAlter_query_element(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAlter_query_element"):
                listener.exitAlter_query_element(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAlter_query_element"):
                return visitor.visitAlter_query_element(self)
            else:
                return visitor.visitChildren(self)

    def alter_query_element(self):

        localctx = ClickHouseParser.Alter_query_elementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_alter_query_element)
        self._la = 0  # Token type
        try:
            self.state = 594
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 70, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 563
                self.match(ClickHouseParser.K_ADD)
                self.state = 564
                self.match(ClickHouseParser.K_COLUMN)
                self.state = 565
                self.compound_name_type_pair()
                self.state = 568
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == ClickHouseParser.K_AFTER:
                    self.state = 566
                    self.match(ClickHouseParser.K_AFTER)
                    self.state = 567
                    self.column_name()

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 570
                self.match(ClickHouseParser.K_DROP)
                self.state = 571
                self.match(ClickHouseParser.K_COLUMN)
                self.state = 572
                self.column_name()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 573
                self.match(ClickHouseParser.K_MODIFY)
                self.state = 574
                self.match(ClickHouseParser.K_COLUMN)
                self.state = 575
                self.compound_name_type_pair()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 576
                self.match(ClickHouseParser.K_ATTACH)
                self.state = 577
                self.match(ClickHouseParser.K_PARTITION)
                self.state = 578
                self.partition_name()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 579
                self.match(ClickHouseParser.K_DETACH)
                self.state = 580
                self.match(ClickHouseParser.K_PARTITION)
                self.state = 581
                self.partition_name()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 582
                self.match(ClickHouseParser.K_DROP)
                self.state = 583
                self.match(ClickHouseParser.K_PARTITION)
                self.state = 584
                self.partition_name()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 585
                self.match(ClickHouseParser.K_FETCH)
                self.state = 586
                self.match(ClickHouseParser.K_PARTITION)
                self.state = 587
                self.partition_name()
                self.state = 588
                self.match(ClickHouseParser.K_FROM)
                self.state = 589
                self.match(ClickHouseParser.STRING_LITERAL)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 591
                self.match(ClickHouseParser.K_FREEZE)
                self.state = 592
                self.match(ClickHouseParser.K_PARTITION)
                self.state = 593
                self.partition_name()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Clickhouse_typeContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simple_type(self):
            return self.getTypedRuleContext(ClickHouseParser.Simple_typeContext, 0)

        def T_AGGREGATE_FUNCTION(self):
            return self.getToken(ClickHouseParser.T_AGGREGATE_FUNCTION, 0)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)

        def function_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Function_nameContext, 0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def clickhouse_type(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.Clickhouse_typeContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.Clickhouse_typeContext, i)

        def T_ARRAY(self):
            return self.getToken(ClickHouseParser.T_ARRAY, 0)

        def T_TUPLE(self):
            return self.getToken(ClickHouseParser.T_TUPLE, 0)

        def T_NULLABLE(self):
            return self.getToken(ClickHouseParser.T_NULLABLE, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_clickhouse_type

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterClickhouse_type"):
                listener.enterClickhouse_type(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitClickhouse_type"):
                listener.exitClickhouse_type(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClickhouse_type"):
                return visitor.visitClickhouse_type(self)
            else:
                return visitor.visitChildren(self)

    def clickhouse_type(self):

        localctx = ClickHouseParser.Clickhouse_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_clickhouse_type)
        self._la = 0  # Token type
        try:
            self.state = 631
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [
                ClickHouseParser.T_FLOAT32,
                ClickHouseParser.T_FLOAT64,
                ClickHouseParser.T_UINT8,
                ClickHouseParser.T_UINT16,
                ClickHouseParser.T_UINT32,
                ClickHouseParser.T_UINT64,
                ClickHouseParser.T_INT8,
                ClickHouseParser.T_INT16,
                ClickHouseParser.T_INT32,
                ClickHouseParser.T_INT64,
                ClickHouseParser.T_ENUM8,
                ClickHouseParser.T_ENUM16,
                ClickHouseParser.T_UUID,
                ClickHouseParser.T_DATE,
                ClickHouseParser.T_DATETIME,
                ClickHouseParser.T_STRING,
                ClickHouseParser.T_FIXEDSTRING,
                ClickHouseParser.T_NULL,
                ClickHouseParser.T_INTERVAL_YEAR,
                ClickHouseParser.T_INTERVAL_MONTH,
                ClickHouseParser.T_INTERVAL_WEEK,
                ClickHouseParser.T_INTERVAL_DAY,
                ClickHouseParser.T_INTERVAL_HOUR,
                ClickHouseParser.T_INTERVAL_MINUTE,
                ClickHouseParser.T_INTERVAL_SECOND,
            ]:
                self.enterOuterAlt(localctx, 1)
                self.state = 596
                self.simple_type()
                pass
            elif token in [ClickHouseParser.T_AGGREGATE_FUNCTION]:
                self.enterOuterAlt(localctx, 2)
                self.state = 597
                self.match(ClickHouseParser.T_AGGREGATE_FUNCTION)
                self.state = 598
                self.match(ClickHouseParser.LPAREN)
                self.state = 599
                self.function_name()
                self.state = 604
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == ClickHouseParser.COMMA:
                    self.state = 600
                    self.match(ClickHouseParser.COMMA)
                    self.state = 601
                    self.clickhouse_type()
                    self.state = 606
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 607
                self.match(ClickHouseParser.RPAREN)
                pass
            elif token in [ClickHouseParser.T_ARRAY]:
                self.enterOuterAlt(localctx, 3)
                self.state = 609
                self.match(ClickHouseParser.T_ARRAY)
                self.state = 610
                self.match(ClickHouseParser.LPAREN)
                self.state = 611
                self.clickhouse_type()
                self.state = 612
                self.match(ClickHouseParser.RPAREN)
                pass
            elif token in [ClickHouseParser.T_TUPLE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 614
                self.match(ClickHouseParser.T_TUPLE)
                self.state = 615
                self.match(ClickHouseParser.LPAREN)
                self.state = 616
                self.clickhouse_type()
                self.state = 621
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == ClickHouseParser.COMMA:
                    self.state = 617
                    self.match(ClickHouseParser.COMMA)
                    self.state = 618
                    self.clickhouse_type()
                    self.state = 623
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 624
                self.match(ClickHouseParser.RPAREN)
                pass
            elif token in [ClickHouseParser.T_NULLABLE]:
                self.enterOuterAlt(localctx, 5)
                self.state = 626
                self.match(ClickHouseParser.T_NULLABLE)
                self.state = 627
                self.match(ClickHouseParser.LPAREN)
                self.state = 628
                self.clickhouse_type()
                self.state = 629
                self.match(ClickHouseParser.RPAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Simple_typeContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_UINT8(self):
            return self.getToken(ClickHouseParser.T_UINT8, 0)

        def T_UINT16(self):
            return self.getToken(ClickHouseParser.T_UINT16, 0)

        def T_UINT32(self):
            return self.getToken(ClickHouseParser.T_UINT32, 0)

        def T_UINT64(self):
            return self.getToken(ClickHouseParser.T_UINT64, 0)

        def T_INT8(self):
            return self.getToken(ClickHouseParser.T_INT8, 0)

        def T_INT16(self):
            return self.getToken(ClickHouseParser.T_INT16, 0)

        def T_INT32(self):
            return self.getToken(ClickHouseParser.T_INT32, 0)

        def T_INT64(self):
            return self.getToken(ClickHouseParser.T_INT64, 0)

        def T_FLOAT32(self):
            return self.getToken(ClickHouseParser.T_FLOAT32, 0)

        def T_FLOAT64(self):
            return self.getToken(ClickHouseParser.T_FLOAT64, 0)

        def T_ENUM8(self):
            return self.getToken(ClickHouseParser.T_ENUM8, 0)

        def LPAREN(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.LPAREN)
            else:
                return self.getToken(ClickHouseParser.LPAREN, i)

        def enum_entry(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.Enum_entryContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.Enum_entryContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def T_ENUM16(self):
            return self.getToken(ClickHouseParser.T_ENUM16, 0)

        def T_UUID(self):
            return self.getToken(ClickHouseParser.T_UUID, 0)

        def T_DATE(self):
            return self.getToken(ClickHouseParser.T_DATE, 0)

        def T_DATETIME(self):
            return self.getToken(ClickHouseParser.T_DATETIME, 0)

        def T_STRING(self):
            return self.getToken(ClickHouseParser.T_STRING, 0)

        def T_INTERVAL_YEAR(self):
            return self.getToken(ClickHouseParser.T_INTERVAL_YEAR, 0)

        def T_INTERVAL_MONTH(self):
            return self.getToken(ClickHouseParser.T_INTERVAL_MONTH, 0)

        def T_INTERVAL_WEEK(self):
            return self.getToken(ClickHouseParser.T_INTERVAL_WEEK, 0)

        def T_INTERVAL_DAY(self):
            return self.getToken(ClickHouseParser.T_INTERVAL_DAY, 0)

        def T_INTERVAL_HOUR(self):
            return self.getToken(ClickHouseParser.T_INTERVAL_HOUR, 0)

        def T_INTERVAL_MINUTE(self):
            return self.getToken(ClickHouseParser.T_INTERVAL_MINUTE, 0)

        def T_INTERVAL_SECOND(self):
            return self.getToken(ClickHouseParser.T_INTERVAL_SECOND, 0)

        def T_NULL(self):
            return self.getToken(ClickHouseParser.T_NULL, 0)

        def T_FIXEDSTRING(self):
            return self.getToken(ClickHouseParser.T_FIXEDSTRING, 0)

        def NUMERIC_LITERAL(self):
            return self.getToken(ClickHouseParser.NUMERIC_LITERAL, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_simple_type

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSimple_type"):
                listener.enterSimple_type(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSimple_type"):
                listener.exitSimple_type(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSimple_type"):
                return visitor.visitSimple_type(self)
            else:
                return visitor.visitChildren(self)

    def simple_type(self):

        localctx = ClickHouseParser.Simple_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_simple_type)
        self._la = 0  # Token type
        try:
            self.state = 683
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ClickHouseParser.T_UINT8]:
                self.enterOuterAlt(localctx, 1)
                self.state = 633
                self.match(ClickHouseParser.T_UINT8)
                pass
            elif token in [ClickHouseParser.T_UINT16]:
                self.enterOuterAlt(localctx, 2)
                self.state = 634
                self.match(ClickHouseParser.T_UINT16)
                pass
            elif token in [ClickHouseParser.T_UINT32]:
                self.enterOuterAlt(localctx, 3)
                self.state = 635
                self.match(ClickHouseParser.T_UINT32)
                pass
            elif token in [ClickHouseParser.T_UINT64]:
                self.enterOuterAlt(localctx, 4)
                self.state = 636
                self.match(ClickHouseParser.T_UINT64)
                pass
            elif token in [ClickHouseParser.T_INT8]:
                self.enterOuterAlt(localctx, 5)
                self.state = 637
                self.match(ClickHouseParser.T_INT8)
                pass
            elif token in [ClickHouseParser.T_INT16]:
                self.enterOuterAlt(localctx, 6)
                self.state = 638
                self.match(ClickHouseParser.T_INT16)
                pass
            elif token in [ClickHouseParser.T_INT32]:
                self.enterOuterAlt(localctx, 7)
                self.state = 639
                self.match(ClickHouseParser.T_INT32)
                pass
            elif token in [ClickHouseParser.T_INT64]:
                self.enterOuterAlt(localctx, 8)
                self.state = 640
                self.match(ClickHouseParser.T_INT64)
                pass
            elif token in [ClickHouseParser.T_FLOAT32]:
                self.enterOuterAlt(localctx, 9)
                self.state = 641
                self.match(ClickHouseParser.T_FLOAT32)
                pass
            elif token in [ClickHouseParser.T_FLOAT64]:
                self.enterOuterAlt(localctx, 10)
                self.state = 642
                self.match(ClickHouseParser.T_FLOAT64)
                pass
            elif token in [ClickHouseParser.T_ENUM8]:
                self.enterOuterAlt(localctx, 11)
                self.state = 643
                self.match(ClickHouseParser.T_ENUM8)
                self.state = 644
                self.match(ClickHouseParser.LPAREN)
                self.state = 645
                self.enum_entry()
                self.state = 650
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == ClickHouseParser.COMMA:
                    self.state = 646
                    self.match(ClickHouseParser.COMMA)
                    self.state = 647
                    self.enum_entry()
                    self.state = 652
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 653
                self.match(ClickHouseParser.LPAREN)
                pass
            elif token in [ClickHouseParser.T_ENUM16]:
                self.enterOuterAlt(localctx, 12)
                self.state = 655
                self.match(ClickHouseParser.T_ENUM16)
                self.state = 656
                self.match(ClickHouseParser.LPAREN)
                self.state = 657
                self.enum_entry()
                self.state = 662
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == ClickHouseParser.COMMA:
                    self.state = 658
                    self.match(ClickHouseParser.COMMA)
                    self.state = 659
                    self.enum_entry()
                    self.state = 664
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 665
                self.match(ClickHouseParser.LPAREN)
                pass
            elif token in [ClickHouseParser.T_UUID]:
                self.enterOuterAlt(localctx, 13)
                self.state = 667
                self.match(ClickHouseParser.T_UUID)
                pass
            elif token in [ClickHouseParser.T_DATE]:
                self.enterOuterAlt(localctx, 14)
                self.state = 668
                self.match(ClickHouseParser.T_DATE)
                pass
            elif token in [ClickHouseParser.T_DATETIME]:
                self.enterOuterAlt(localctx, 15)
                self.state = 669
                self.match(ClickHouseParser.T_DATETIME)
                pass
            elif token in [ClickHouseParser.T_STRING]:
                self.enterOuterAlt(localctx, 16)
                self.state = 670
                self.match(ClickHouseParser.T_STRING)
                pass
            elif token in [ClickHouseParser.T_INTERVAL_YEAR]:
                self.enterOuterAlt(localctx, 17)
                self.state = 671
                self.match(ClickHouseParser.T_INTERVAL_YEAR)
                pass
            elif token in [ClickHouseParser.T_INTERVAL_MONTH]:
                self.enterOuterAlt(localctx, 18)
                self.state = 672
                self.match(ClickHouseParser.T_INTERVAL_MONTH)
                pass
            elif token in [ClickHouseParser.T_INTERVAL_WEEK]:
                self.enterOuterAlt(localctx, 19)
                self.state = 673
                self.match(ClickHouseParser.T_INTERVAL_WEEK)
                pass
            elif token in [ClickHouseParser.T_INTERVAL_DAY]:
                self.enterOuterAlt(localctx, 20)
                self.state = 674
                self.match(ClickHouseParser.T_INTERVAL_DAY)
                pass
            elif token in [ClickHouseParser.T_INTERVAL_HOUR]:
                self.enterOuterAlt(localctx, 21)
                self.state = 675
                self.match(ClickHouseParser.T_INTERVAL_HOUR)
                pass
            elif token in [ClickHouseParser.T_INTERVAL_MINUTE]:
                self.enterOuterAlt(localctx, 22)
                self.state = 676
                self.match(ClickHouseParser.T_INTERVAL_MINUTE)
                pass
            elif token in [ClickHouseParser.T_INTERVAL_SECOND]:
                self.enterOuterAlt(localctx, 23)
                self.state = 677
                self.match(ClickHouseParser.T_INTERVAL_SECOND)
                pass
            elif token in [ClickHouseParser.T_NULL]:
                self.enterOuterAlt(localctx, 24)
                self.state = 678
                self.match(ClickHouseParser.T_NULL)
                pass
            elif token in [ClickHouseParser.T_FIXEDSTRING]:
                self.enterOuterAlt(localctx, 25)
                self.state = 679
                self.match(ClickHouseParser.T_FIXEDSTRING)
                self.state = 680
                self.match(ClickHouseParser.LPAREN)
                self.state = 681
                self.match(ClickHouseParser.NUMERIC_LITERAL)
                self.state = 682
                self.match(ClickHouseParser.LPAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Enum_entryContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_LITERAL(self):
            return self.getToken(ClickHouseParser.STRING_LITERAL, 0)

        def ASSIGN(self):
            return self.getToken(ClickHouseParser.ASSIGN, 0)

        def NUMERIC_LITERAL(self):
            return self.getToken(ClickHouseParser.NUMERIC_LITERAL, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_enum_entry

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEnum_entry"):
                listener.enterEnum_entry(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEnum_entry"):
                listener.exitEnum_entry(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEnum_entry"):
                return visitor.visitEnum_entry(self)
            else:
                return visitor.visitChildren(self)

    def enum_entry(self):

        localctx = ClickHouseParser.Enum_entryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_enum_entry)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 685
            self.match(ClickHouseParser.STRING_LITERAL)
            self.state = 686
            self.match(ClickHouseParser.ASSIGN)
            self.state = 687
            self.match(ClickHouseParser.NUMERIC_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Use_queryContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_USE(self):
            return self.getToken(ClickHouseParser.K_USE, 0)

        def database_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Database_nameContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_use_query

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUse_query"):
                listener.enterUse_query(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUse_query"):
                listener.exitUse_query(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUse_query"):
                return visitor.visitUse_query(self)
            else:
                return visitor.visitChildren(self)

    def use_query(self):

        localctx = ClickHouseParser.Use_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_use_query)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 689
            self.match(ClickHouseParser.K_USE)
            self.state = 690
            self.database_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Set_queryContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_SET(self):
            return self.getToken(ClickHouseParser.K_SET, 0)

        def assignment_list(self):
            return self.getTypedRuleContext(ClickHouseParser.Assignment_listContext, 0)

        def K_GLOBAL(self):
            return self.getToken(ClickHouseParser.K_GLOBAL, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_set_query

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSet_query"):
                listener.enterSet_query(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSet_query"):
                listener.exitSet_query(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSet_query"):
                return visitor.visitSet_query(self)
            else:
                return visitor.visitChildren(self)

    def set_query(self):

        localctx = ClickHouseParser.Set_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_set_query)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 692
            self.match(ClickHouseParser.K_SET)
            self.state = 694
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 77, self._ctx)
            if la_ == 1:
                self.state = 693
                self.match(ClickHouseParser.K_GLOBAL)

            self.state = 696
            self.assignment_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Assignment_listContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.AssignmentContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.AssignmentContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_assignment_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssignment_list"):
                listener.enterAssignment_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssignment_list"):
                listener.exitAssignment_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssignment_list"):
                return visitor.visitAssignment_list(self)
            else:
                return visitor.visitChildren(self)

    def assignment_list(self):

        localctx = ClickHouseParser.Assignment_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_assignment_list)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 698
            self.assignment()
            self.state = 703
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ClickHouseParser.COMMA:
                self.state = 699
                self.match(ClickHouseParser.COMMA)
                self.state = 700
                self.assignment()
                self.state = 705
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssignmentContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext, 0)

        def ASSIGN(self):
            return self.getToken(ClickHouseParser.ASSIGN, 0)

        def literal(self):
            return self.getTypedRuleContext(ClickHouseParser.LiteralContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_assignment

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssignment"):
                listener.enterAssignment(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssignment"):
                listener.exitAssignment(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssignment"):
                return visitor.visitAssignment(self)
            else:
                return visitor.visitChildren(self)

    def assignment(self):

        localctx = ClickHouseParser.AssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_assignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 706
            self.identifier()
            self.state = 707
            self.match(ClickHouseParser.ASSIGN)
            self.state = 708
            self.literal()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Kill_query_queryContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_KILL(self):
            return self.getToken(ClickHouseParser.K_KILL, 0)

        def K_QUERY(self):
            return self.getToken(ClickHouseParser.K_QUERY, 0)

        def K_WHERE(self):
            return self.getToken(ClickHouseParser.K_WHERE, 0)

        def expression_with_optional_alias(self):
            return self.getTypedRuleContext(
                ClickHouseParser.Expression_with_optional_aliasContext, 0
            )

        def K_SYNC(self):
            return self.getToken(ClickHouseParser.K_SYNC, 0)

        def K_ASYNC(self):
            return self.getToken(ClickHouseParser.K_ASYNC, 0)

        def K_TEST(self):
            return self.getToken(ClickHouseParser.K_TEST, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_kill_query_query

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterKill_query_query"):
                listener.enterKill_query_query(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitKill_query_query"):
                listener.exitKill_query_query(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitKill_query_query"):
                return visitor.visitKill_query_query(self)
            else:
                return visitor.visitChildren(self)

    def kill_query_query(self):

        localctx = ClickHouseParser.Kill_query_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_kill_query_query)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 710
            self.match(ClickHouseParser.K_KILL)
            self.state = 711
            self.match(ClickHouseParser.K_QUERY)
            self.state = 712
            self.match(ClickHouseParser.K_WHERE)
            self.state = 713
            self.expression_with_optional_alias()
            self.state = 714
            _la = self._input.LA(1)
            if not (
                _la == ClickHouseParser.K_ASYNC
                or _la == ClickHouseParser.K_SYNC
                or _la == ClickHouseParser.K_TEST
            ):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Optimize_queryContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_OPTIMIZE(self):
            return self.getToken(ClickHouseParser.K_OPTIMIZE, 0)

        def K_TABLE(self):
            return self.getToken(ClickHouseParser.K_TABLE, 0)

        def full_table_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Full_table_nameContext, 0)

        def K_PARTITION(self):
            return self.getToken(ClickHouseParser.K_PARTITION, 0)

        def STRING_LITERAL(self):
            return self.getToken(ClickHouseParser.STRING_LITERAL, 0)

        def K_FINAL(self):
            return self.getToken(ClickHouseParser.K_FINAL, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_optimize_query

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOptimize_query"):
                listener.enterOptimize_query(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOptimize_query"):
                listener.exitOptimize_query(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOptimize_query"):
                return visitor.visitOptimize_query(self)
            else:
                return visitor.visitChildren(self)

    def optimize_query(self):

        localctx = ClickHouseParser.Optimize_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_optimize_query)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 716
            self.match(ClickHouseParser.K_OPTIMIZE)
            self.state = 717
            self.match(ClickHouseParser.K_TABLE)
            self.state = 718
            self.full_table_name()
            self.state = 721
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_PARTITION:
                self.state = 719
                self.match(ClickHouseParser.K_PARTITION)
                self.state = 720
                self.match(ClickHouseParser.STRING_LITERAL)

            self.state = 724
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_FINAL:
                self.state = 723
                self.match(ClickHouseParser.K_FINAL)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Table_properties_queryContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_TABLE(self):
            return self.getToken(ClickHouseParser.K_TABLE, 0)

        def full_table_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Full_table_nameContext, 0)

        def K_EXISTS(self):
            return self.getToken(ClickHouseParser.K_EXISTS, 0)

        def K_SHOW(self):
            return self.getToken(ClickHouseParser.K_SHOW, 0)

        def K_CREATE(self):
            return self.getToken(ClickHouseParser.K_CREATE, 0)

        def K_DESCRIBE(self):
            return self.getToken(ClickHouseParser.K_DESCRIBE, 0)

        def K_DESC(self):
            return self.getToken(ClickHouseParser.K_DESC, 0)

        def query_outfile_step(self):
            return self.getTypedRuleContext(ClickHouseParser.Query_outfile_stepContext, 0)

        def K_FORMAT(self):
            return self.getToken(ClickHouseParser.K_FORMAT, 0)

        def format_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Format_nameContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_table_properties_query

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTable_properties_query"):
                listener.enterTable_properties_query(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTable_properties_query"):
                listener.exitTable_properties_query(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTable_properties_query"):
                return visitor.visitTable_properties_query(self)
            else:
                return visitor.visitChildren(self)

    def table_properties_query(self):

        localctx = ClickHouseParser.Table_properties_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_table_properties_query)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 730
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ClickHouseParser.K_EXISTS]:
                self.state = 726
                self.match(ClickHouseParser.K_EXISTS)
                pass
            elif token in [ClickHouseParser.K_DESCRIBE, ClickHouseParser.K_DESC]:
                self.state = 727
                _la = self._input.LA(1)
                if not (_la == ClickHouseParser.K_DESCRIBE or _la == ClickHouseParser.K_DESC):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [ClickHouseParser.K_SHOW]:
                self.state = 728
                self.match(ClickHouseParser.K_SHOW)
                self.state = 729
                self.match(ClickHouseParser.K_CREATE)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 732
            self.match(ClickHouseParser.K_TABLE)
            self.state = 733
            self.full_table_name()
            self.state = 735
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_INTO:
                self.state = 734
                self.query_outfile_step()

            self.state = 739
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_FORMAT:
                self.state = 737
                self.match(ClickHouseParser.K_FORMAT)
                self.state = 738
                self.format_name()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Show_tables_queryContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_SHOW(self):
            return self.getToken(ClickHouseParser.K_SHOW, 0)

        def K_DATABASES(self):
            return self.getToken(ClickHouseParser.K_DATABASES, 0)

        def K_TABLES(self):
            return self.getToken(ClickHouseParser.K_TABLES, 0)

        def query_outfile_step(self):
            return self.getTypedRuleContext(ClickHouseParser.Query_outfile_stepContext, 0)

        def K_FORMAT(self):
            return self.getToken(ClickHouseParser.K_FORMAT, 0)

        def format_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Format_nameContext, 0)

        def K_FROM(self):
            return self.getToken(ClickHouseParser.K_FROM, 0)

        def database_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Database_nameContext, 0)

        def K_LIKE(self):
            return self.getToken(ClickHouseParser.K_LIKE, 0)

        def STRING_LITERAL(self):
            return self.getToken(ClickHouseParser.STRING_LITERAL, 0)

        def K_NOT(self):
            return self.getToken(ClickHouseParser.K_NOT, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_show_tables_query

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterShow_tables_query"):
                listener.enterShow_tables_query(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitShow_tables_query"):
                listener.exitShow_tables_query(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitShow_tables_query"):
                return visitor.visitShow_tables_query(self)
            else:
                return visitor.visitChildren(self)

    def show_tables_query(self):

        localctx = ClickHouseParser.Show_tables_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_show_tables_query)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 741
            self.match(ClickHouseParser.K_SHOW)
            self.state = 755
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ClickHouseParser.K_DATABASES]:
                self.state = 742
                self.match(ClickHouseParser.K_DATABASES)
                pass
            elif token in [ClickHouseParser.K_TABLES]:
                self.state = 743
                self.match(ClickHouseParser.K_TABLES)
                self.state = 746
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == ClickHouseParser.K_FROM:
                    self.state = 744
                    self.match(ClickHouseParser.K_FROM)
                    self.state = 745
                    self.database_name()

                self.state = 753
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == ClickHouseParser.K_LIKE or _la == ClickHouseParser.K_NOT:
                    self.state = 749
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == ClickHouseParser.K_NOT:
                        self.state = 748
                        self.match(ClickHouseParser.K_NOT)

                    self.state = 751
                    self.match(ClickHouseParser.K_LIKE)
                    self.state = 752
                    self.match(ClickHouseParser.STRING_LITERAL)

                pass
            else:
                raise NoViableAltException(self)

            self.state = 758
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_INTO:
                self.state = 757
                self.query_outfile_step()

            self.state = 762
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_FORMAT:
                self.state = 760
                self.match(ClickHouseParser.K_FORMAT)
                self.state = 761
                self.format_name()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Show_processlist_queryContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_SHOW(self):
            return self.getToken(ClickHouseParser.K_SHOW, 0)

        def K_PROCESSLIST(self):
            return self.getToken(ClickHouseParser.K_PROCESSLIST, 0)

        def query_outfile_step(self):
            return self.getTypedRuleContext(ClickHouseParser.Query_outfile_stepContext, 0)

        def K_FORMAT(self):
            return self.getToken(ClickHouseParser.K_FORMAT, 0)

        def format_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Format_nameContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_show_processlist_query

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterShow_processlist_query"):
                listener.enterShow_processlist_query(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitShow_processlist_query"):
                listener.exitShow_processlist_query(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitShow_processlist_query"):
                return visitor.visitShow_processlist_query(self)
            else:
                return visitor.visitChildren(self)

    def show_processlist_query(self):

        localctx = ClickHouseParser.Show_processlist_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_show_processlist_query)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 764
            self.match(ClickHouseParser.K_SHOW)
            self.state = 765
            self.match(ClickHouseParser.K_PROCESSLIST)
            self.state = 767
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_INTO:
                self.state = 766
                self.query_outfile_step()

            self.state = 771
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_FORMAT:
                self.state = 769
                self.match(ClickHouseParser.K_FORMAT)
                self.state = 770
                self.format_name()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Check_queryContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_CHECK(self):
            return self.getToken(ClickHouseParser.K_CHECK, 0)

        def K_TABLE(self):
            return self.getToken(ClickHouseParser.K_TABLE, 0)

        def full_table_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Full_table_nameContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_check_query

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCheck_query"):
                listener.enterCheck_query(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCheck_query"):
                listener.exitCheck_query(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCheck_query"):
                return visitor.visitCheck_query(self)
            else:
                return visitor.visitChildren(self)

    def check_query(self):

        localctx = ClickHouseParser.Check_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_check_query)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 773
            self.match(ClickHouseParser.K_CHECK)
            self.state = 774
            self.match(ClickHouseParser.K_TABLE)
            self.state = 775
            self.full_table_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Full_table_nameContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Table_nameContext, 0)

        def database_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Database_nameContext, 0)

        def DOT(self):
            return self.getToken(ClickHouseParser.DOT, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_full_table_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFull_table_name"):
                listener.enterFull_table_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFull_table_name"):
                listener.exitFull_table_name(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFull_table_name"):
                return visitor.visitFull_table_name(self)
            else:
                return visitor.visitChildren(self)

    def full_table_name(self):

        localctx = ClickHouseParser.Full_table_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_full_table_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 780
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 92, self._ctx)
            if la_ == 1:
                self.state = 777
                self.database_name()
                self.state = 778
                self.match(ClickHouseParser.DOT)

            self.state = 782
            self.table_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Partition_nameContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext, 0)

        def STRING_LITERAL(self):
            return self.getToken(ClickHouseParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_partition_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPartition_name"):
                listener.enterPartition_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPartition_name"):
                listener.exitPartition_name(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPartition_name"):
                return visitor.visitPartition_name(self)
            else:
                return visitor.visitChildren(self)

    def partition_name(self):

        localctx = ClickHouseParser.Partition_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_partition_name)
        try:
            self.state = 786
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [
                ClickHouseParser.K_ADD,
                ClickHouseParser.K_AFTER,
                ClickHouseParser.K_ALL,
                ClickHouseParser.K_ALIAS,
                ClickHouseParser.K_ALTER,
                ClickHouseParser.K_AND,
                ClickHouseParser.K_ANY,
                ClickHouseParser.K_ARRAY,
                ClickHouseParser.K_AS,
                ClickHouseParser.K_ASCENDING,
                ClickHouseParser.K_ASC,
                ClickHouseParser.K_ASYNC,
                ClickHouseParser.K_ATTACH,
                ClickHouseParser.K_BETWEEN,
                ClickHouseParser.K_BY,
                ClickHouseParser.K_CASE,
                ClickHouseParser.K_CHECK,
                ClickHouseParser.K_COLUMN,
                ClickHouseParser.K_COLLATE,
                ClickHouseParser.K_CREATE,
                ClickHouseParser.K_CROSS,
                ClickHouseParser.K_DESCRIBE,
                ClickHouseParser.K_DESCENDING,
                ClickHouseParser.K_DESC,
                ClickHouseParser.K_DATABASE,
                ClickHouseParser.K_DATABASES,
                ClickHouseParser.K_DEFAULT,
                ClickHouseParser.K_DETACH,
                ClickHouseParser.K_DISTINCT,
                ClickHouseParser.K_DROP,
                ClickHouseParser.K_ELSE,
                ClickHouseParser.K_END,
                ClickHouseParser.K_ENGINE,
                ClickHouseParser.K_EXISTS,
                ClickHouseParser.K_FINAL,
                ClickHouseParser.K_FIRST,
                ClickHouseParser.K_FROM,
                ClickHouseParser.K_FORMAT,
                ClickHouseParser.K_FULL,
                ClickHouseParser.K_GLOBAL,
                ClickHouseParser.K_GROUP,
                ClickHouseParser.K_HAVING,
                ClickHouseParser.K_ID,
                ClickHouseParser.K_IF,
                ClickHouseParser.K_INNER,
                ClickHouseParser.K_INSERT,
                ClickHouseParser.K_INTO,
                ClickHouseParser.K_IN,
                ClickHouseParser.K_IS,
                ClickHouseParser.K_JOIN,
                ClickHouseParser.K_KILL,
                ClickHouseParser.K_LAST,
                ClickHouseParser.K_LEFT,
                ClickHouseParser.K_LIKE,
                ClickHouseParser.K_LIMIT,
                ClickHouseParser.K_MAIN,
                ClickHouseParser.K_MATERIALIZED,
                ClickHouseParser.K_MODIFY,
                ClickHouseParser.K_NOT,
                ClickHouseParser.K_NULL,
                ClickHouseParser.K_NULLS,
                ClickHouseParser.K_OFFSET,
                ClickHouseParser.K_ON,
                ClickHouseParser.K_OPTIMIZE,
                ClickHouseParser.K_ORDER,
                ClickHouseParser.K_OR,
                ClickHouseParser.K_OUTFILE,
                ClickHouseParser.K_PARTITION,
                ClickHouseParser.K_POPULATE,
                ClickHouseParser.K_PREWHERE,
                ClickHouseParser.K_PROCESSLIST,
                ClickHouseParser.K_QUERY,
                ClickHouseParser.K_RENAME,
                ClickHouseParser.K_RETURN,
                ClickHouseParser.K_RIGHT,
                ClickHouseParser.K_SAMPLE,
                ClickHouseParser.K_SELECT,
                ClickHouseParser.K_SET,
                ClickHouseParser.K_SETTINGS,
                ClickHouseParser.K_SHOW,
                ClickHouseParser.K_SYNC,
                ClickHouseParser.K_TABLE,
                ClickHouseParser.K_TABLES,
                ClickHouseParser.K_TEMPORARY,
                ClickHouseParser.K_TEST,
                ClickHouseParser.K_THEN,
                ClickHouseParser.K_TOTALS,
                ClickHouseParser.K_TO,
                ClickHouseParser.K_OUTER,
                ClickHouseParser.K_VALUES,
                ClickHouseParser.K_VIEW,
                ClickHouseParser.K_UNION,
                ClickHouseParser.K_USE,
                ClickHouseParser.K_USING,
                ClickHouseParser.K_WHEN,
                ClickHouseParser.K_WHERE,
                ClickHouseParser.K_WITH,
                ClickHouseParser.T_FLOAT32,
                ClickHouseParser.T_FLOAT64,
                ClickHouseParser.T_UINT8,
                ClickHouseParser.T_UINT16,
                ClickHouseParser.T_UINT32,
                ClickHouseParser.T_UINT64,
                ClickHouseParser.T_INT8,
                ClickHouseParser.T_INT16,
                ClickHouseParser.T_INT32,
                ClickHouseParser.T_INT64,
                ClickHouseParser.T_ENUM8,
                ClickHouseParser.T_ENUM16,
                ClickHouseParser.T_UUID,
                ClickHouseParser.T_DATE,
                ClickHouseParser.T_DATETIME,
                ClickHouseParser.T_STRING,
                ClickHouseParser.T_FIXEDSTRING,
                ClickHouseParser.T_NULL,
                ClickHouseParser.T_INTERVAL_YEAR,
                ClickHouseParser.T_INTERVAL_MONTH,
                ClickHouseParser.T_INTERVAL_WEEK,
                ClickHouseParser.T_INTERVAL_DAY,
                ClickHouseParser.T_INTERVAL_HOUR,
                ClickHouseParser.T_INTERVAL_MINUTE,
                ClickHouseParser.T_INTERVAL_SECOND,
                ClickHouseParser.IDENTIFIER,
                ClickHouseParser.QUOTED_LITERAL,
            ]:
                self.enterOuterAlt(localctx, 1)
                self.state = 784
                self.identifier()
                pass
            elif token in [ClickHouseParser.STRING_LITERAL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 785
                self.match(ClickHouseParser.STRING_LITERAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Cluster_nameContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext, 0)

        def STRING_LITERAL(self):
            return self.getToken(ClickHouseParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_cluster_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCluster_name"):
                listener.enterCluster_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCluster_name"):
                listener.exitCluster_name(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCluster_name"):
                return visitor.visitCluster_name(self)
            else:
                return visitor.visitChildren(self)

    def cluster_name(self):

        localctx = ClickHouseParser.Cluster_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_cluster_name)
        try:
            self.state = 790
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [
                ClickHouseParser.K_ADD,
                ClickHouseParser.K_AFTER,
                ClickHouseParser.K_ALL,
                ClickHouseParser.K_ALIAS,
                ClickHouseParser.K_ALTER,
                ClickHouseParser.K_AND,
                ClickHouseParser.K_ANY,
                ClickHouseParser.K_ARRAY,
                ClickHouseParser.K_AS,
                ClickHouseParser.K_ASCENDING,
                ClickHouseParser.K_ASC,
                ClickHouseParser.K_ASYNC,
                ClickHouseParser.K_ATTACH,
                ClickHouseParser.K_BETWEEN,
                ClickHouseParser.K_BY,
                ClickHouseParser.K_CASE,
                ClickHouseParser.K_CHECK,
                ClickHouseParser.K_COLUMN,
                ClickHouseParser.K_COLLATE,
                ClickHouseParser.K_CREATE,
                ClickHouseParser.K_CROSS,
                ClickHouseParser.K_DESCRIBE,
                ClickHouseParser.K_DESCENDING,
                ClickHouseParser.K_DESC,
                ClickHouseParser.K_DATABASE,
                ClickHouseParser.K_DATABASES,
                ClickHouseParser.K_DEFAULT,
                ClickHouseParser.K_DETACH,
                ClickHouseParser.K_DISTINCT,
                ClickHouseParser.K_DROP,
                ClickHouseParser.K_ELSE,
                ClickHouseParser.K_END,
                ClickHouseParser.K_ENGINE,
                ClickHouseParser.K_EXISTS,
                ClickHouseParser.K_FINAL,
                ClickHouseParser.K_FIRST,
                ClickHouseParser.K_FROM,
                ClickHouseParser.K_FORMAT,
                ClickHouseParser.K_FULL,
                ClickHouseParser.K_GLOBAL,
                ClickHouseParser.K_GROUP,
                ClickHouseParser.K_HAVING,
                ClickHouseParser.K_ID,
                ClickHouseParser.K_IF,
                ClickHouseParser.K_INNER,
                ClickHouseParser.K_INSERT,
                ClickHouseParser.K_INTO,
                ClickHouseParser.K_IN,
                ClickHouseParser.K_IS,
                ClickHouseParser.K_JOIN,
                ClickHouseParser.K_KILL,
                ClickHouseParser.K_LAST,
                ClickHouseParser.K_LEFT,
                ClickHouseParser.K_LIKE,
                ClickHouseParser.K_LIMIT,
                ClickHouseParser.K_MAIN,
                ClickHouseParser.K_MATERIALIZED,
                ClickHouseParser.K_MODIFY,
                ClickHouseParser.K_NOT,
                ClickHouseParser.K_NULL,
                ClickHouseParser.K_NULLS,
                ClickHouseParser.K_OFFSET,
                ClickHouseParser.K_ON,
                ClickHouseParser.K_OPTIMIZE,
                ClickHouseParser.K_ORDER,
                ClickHouseParser.K_OR,
                ClickHouseParser.K_OUTFILE,
                ClickHouseParser.K_PARTITION,
                ClickHouseParser.K_POPULATE,
                ClickHouseParser.K_PREWHERE,
                ClickHouseParser.K_PROCESSLIST,
                ClickHouseParser.K_QUERY,
                ClickHouseParser.K_RENAME,
                ClickHouseParser.K_RETURN,
                ClickHouseParser.K_RIGHT,
                ClickHouseParser.K_SAMPLE,
                ClickHouseParser.K_SELECT,
                ClickHouseParser.K_SET,
                ClickHouseParser.K_SETTINGS,
                ClickHouseParser.K_SHOW,
                ClickHouseParser.K_SYNC,
                ClickHouseParser.K_TABLE,
                ClickHouseParser.K_TABLES,
                ClickHouseParser.K_TEMPORARY,
                ClickHouseParser.K_TEST,
                ClickHouseParser.K_THEN,
                ClickHouseParser.K_TOTALS,
                ClickHouseParser.K_TO,
                ClickHouseParser.K_OUTER,
                ClickHouseParser.K_VALUES,
                ClickHouseParser.K_VIEW,
                ClickHouseParser.K_UNION,
                ClickHouseParser.K_USE,
                ClickHouseParser.K_USING,
                ClickHouseParser.K_WHEN,
                ClickHouseParser.K_WHERE,
                ClickHouseParser.K_WITH,
                ClickHouseParser.T_FLOAT32,
                ClickHouseParser.T_FLOAT64,
                ClickHouseParser.T_UINT8,
                ClickHouseParser.T_UINT16,
                ClickHouseParser.T_UINT32,
                ClickHouseParser.T_UINT64,
                ClickHouseParser.T_INT8,
                ClickHouseParser.T_INT16,
                ClickHouseParser.T_INT32,
                ClickHouseParser.T_INT64,
                ClickHouseParser.T_ENUM8,
                ClickHouseParser.T_ENUM16,
                ClickHouseParser.T_UUID,
                ClickHouseParser.T_DATE,
                ClickHouseParser.T_DATETIME,
                ClickHouseParser.T_STRING,
                ClickHouseParser.T_FIXEDSTRING,
                ClickHouseParser.T_NULL,
                ClickHouseParser.T_INTERVAL_YEAR,
                ClickHouseParser.T_INTERVAL_MONTH,
                ClickHouseParser.T_INTERVAL_WEEK,
                ClickHouseParser.T_INTERVAL_DAY,
                ClickHouseParser.T_INTERVAL_HOUR,
                ClickHouseParser.T_INTERVAL_MINUTE,
                ClickHouseParser.T_INTERVAL_SECOND,
                ClickHouseParser.IDENTIFIER,
                ClickHouseParser.QUOTED_LITERAL,
            ]:
                self.enterOuterAlt(localctx, 1)
                self.state = 788
                self.identifier()
                pass
            elif token in [ClickHouseParser.STRING_LITERAL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 789
                self.match(ClickHouseParser.STRING_LITERAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Database_nameContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_database_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDatabase_name"):
                listener.enterDatabase_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDatabase_name"):
                listener.exitDatabase_name(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDatabase_name"):
                return visitor.visitDatabase_name(self)
            else:
                return visitor.visitChildren(self)

    def database_name(self):

        localctx = ClickHouseParser.Database_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_database_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 792
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Table_nameContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_table_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTable_name"):
                listener.enterTable_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTable_name"):
                listener.exitTable_name(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTable_name"):
                return visitor.visitTable_name(self)
            else:
                return visitor.visitChildren(self)

    def table_name(self):

        localctx = ClickHouseParser.Table_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_table_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 794
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Format_nameContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_format_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormat_name"):
                listener.enterFormat_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormat_name"):
                listener.exitFormat_name(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormat_name"):
                return visitor.visitFormat_name(self)
            else:
                return visitor.visitChildren(self)

    def format_name(self):

        localctx = ClickHouseParser.Format_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_format_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 796
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Query_outfile_stepContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_INTO(self):
            return self.getToken(ClickHouseParser.K_INTO, 0)

        def K_OUTFILE(self):
            return self.getToken(ClickHouseParser.K_OUTFILE, 0)

        def STRING_LITERAL(self):
            return self.getToken(ClickHouseParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_query_outfile_step

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterQuery_outfile_step"):
                listener.enterQuery_outfile_step(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitQuery_outfile_step"):
                listener.exitQuery_outfile_step(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitQuery_outfile_step"):
                return visitor.visitQuery_outfile_step(self)
            else:
                return visitor.visitChildren(self)

    def query_outfile_step(self):

        localctx = ClickHouseParser.Query_outfile_stepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_query_outfile_step)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 798
            self.match(ClickHouseParser.K_INTO)
            self.state = 799
            self.match(ClickHouseParser.K_OUTFILE)
            self.state = 800
            self.match(ClickHouseParser.STRING_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EngineContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_ENGINE(self):
            return self.getToken(ClickHouseParser.K_ENGINE, 0)

        def ASSIGN(self):
            return self.getToken(ClickHouseParser.ASSIGN, 0)

        def identifier_with_optional_parameters(self):
            return self.getTypedRuleContext(
                ClickHouseParser.Identifier_with_optional_parametersContext, 0
            )

        def getRuleIndex(self):
            return ClickHouseParser.RULE_engine

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEngine"):
                listener.enterEngine(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEngine"):
                listener.exitEngine(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEngine"):
                return visitor.visitEngine(self)
            else:
                return visitor.visitChildren(self)

    def engine(self):

        localctx = ClickHouseParser.EngineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_engine)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 802
            self.match(ClickHouseParser.K_ENGINE)
            self.state = 803
            self.match(ClickHouseParser.ASSIGN)
            self.state = 804
            self.identifier_with_optional_parameters()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Identifier_with_optional_parametersContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier_with_parameters(self):
            return self.getTypedRuleContext(ClickHouseParser.Identifier_with_parametersContext, 0)

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_identifier_with_optional_parameters

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIdentifier_with_optional_parameters"):
                listener.enterIdentifier_with_optional_parameters(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIdentifier_with_optional_parameters"):
                listener.exitIdentifier_with_optional_parameters(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIdentifier_with_optional_parameters"):
                return visitor.visitIdentifier_with_optional_parameters(self)
            else:
                return visitor.visitChildren(self)

    def identifier_with_optional_parameters(self):

        localctx = ClickHouseParser.Identifier_with_optional_parametersContext(
            self, self._ctx, self.state
        )
        self.enterRule(localctx, 96, self.RULE_identifier_with_optional_parameters)
        try:
            self.state = 808
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 95, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 806
                self.identifier_with_parameters()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 807
                self.identifier()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Identifier_with_parametersContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def function(self):
            return self.getTypedRuleContext(ClickHouseParser.FunctionContext, 0)

        def nested_table(self):
            return self.getTypedRuleContext(ClickHouseParser.Nested_tableContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_identifier_with_parameters

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIdentifier_with_parameters"):
                listener.enterIdentifier_with_parameters(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIdentifier_with_parameters"):
                listener.exitIdentifier_with_parameters(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIdentifier_with_parameters"):
                return visitor.visitIdentifier_with_parameters(self)
            else:
                return visitor.visitChildren(self)

    def identifier_with_parameters(self):

        localctx = ClickHouseParser.Identifier_with_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_identifier_with_parameters)
        try:
            self.state = 812
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 96, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 810
                self.function()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 811
                self.nested_table()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Order_by_expression_listContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def order_by_element(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.Order_by_elementContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.Order_by_elementContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_order_by_expression_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOrder_by_expression_list"):
                listener.enterOrder_by_expression_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOrder_by_expression_list"):
                listener.exitOrder_by_expression_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOrder_by_expression_list"):
                return visitor.visitOrder_by_expression_list(self)
            else:
                return visitor.visitChildren(self)

    def order_by_expression_list(self):

        localctx = ClickHouseParser.Order_by_expression_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_order_by_expression_list)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 814
            self.order_by_element()
            self.state = 819
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ClickHouseParser.COMMA:
                self.state = 815
                self.match(ClickHouseParser.COMMA)
                self.state = 816
                self.order_by_element()
                self.state = 821
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Order_by_elementContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression_with_optional_alias(self):
            return self.getTypedRuleContext(
                ClickHouseParser.Expression_with_optional_aliasContext, 0
            )

        def K_NULLS(self):
            return self.getToken(ClickHouseParser.K_NULLS, 0)

        def K_COLLATE(self):
            return self.getToken(ClickHouseParser.K_COLLATE, 0)

        def STRING_LITERAL(self):
            return self.getToken(ClickHouseParser.STRING_LITERAL, 0)

        def K_DESC(self):
            return self.getToken(ClickHouseParser.K_DESC, 0)

        def K_DESCENDING(self):
            return self.getToken(ClickHouseParser.K_DESCENDING, 0)

        def K_ASC(self):
            return self.getToken(ClickHouseParser.K_ASC, 0)

        def K_ASCENDING(self):
            return self.getToken(ClickHouseParser.K_ASCENDING, 0)

        def K_FIRST(self):
            return self.getToken(ClickHouseParser.K_FIRST, 0)

        def K_LAST(self):
            return self.getToken(ClickHouseParser.K_LAST, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_order_by_element

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOrder_by_element"):
                listener.enterOrder_by_element(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOrder_by_element"):
                listener.exitOrder_by_element(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOrder_by_element"):
                return visitor.visitOrder_by_element(self)
            else:
                return visitor.visitChildren(self)

    def order_by_element(self):

        localctx = ClickHouseParser.Order_by_elementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_order_by_element)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 822
            self.expression_with_optional_alias()
            self.state = 824
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((_la) & ~0x3F) == 0 and (
                (1 << _la)
                & (
                    (1 << ClickHouseParser.K_ASCENDING)
                    | (1 << ClickHouseParser.K_ASC)
                    | (1 << ClickHouseParser.K_DESCENDING)
                    | (1 << ClickHouseParser.K_DESC)
                )
            ) != 0:
                self.state = 823
                _la = self._input.LA(1)
                if not (
                    (
                        ((_la) & ~0x3F) == 0
                        and (
                            (1 << _la)
                            & (
                                (1 << ClickHouseParser.K_ASCENDING)
                                | (1 << ClickHouseParser.K_ASC)
                                | (1 << ClickHouseParser.K_DESCENDING)
                                | (1 << ClickHouseParser.K_DESC)
                            )
                        )
                        != 0
                    )
                ):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

            self.state = 828
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_NULLS:
                self.state = 826
                self.match(ClickHouseParser.K_NULLS)
                self.state = 827
                _la = self._input.LA(1)
                if not (_la == ClickHouseParser.K_FIRST or _la == ClickHouseParser.K_LAST):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

            self.state = 832
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_COLLATE:
                self.state = 830
                self.match(ClickHouseParser.K_COLLATE)
                self.state = 831
                self.match(ClickHouseParser.STRING_LITERAL)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Table_ttl_listContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_TTL(self):
            return self.getToken(ClickHouseParser.K_TTL, 0)

        def table_ttl_declaration(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.Table_ttl_declarationContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.Table_ttl_declarationContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_table_ttl_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTable_ttl_list"):
                listener.enterTable_ttl_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTable_ttl_list"):
                listener.exitTable_ttl_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTable_ttl_list"):
                return visitor.visitTable_ttl_list(self)
            else:
                return visitor.visitChildren(self)

    def table_ttl_list(self):

        localctx = ClickHouseParser.Table_ttl_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_table_ttl_list)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 834
            self.match(ClickHouseParser.K_TTL)
            self.state = 835
            self.table_ttl_declaration()
            self.state = 840
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ClickHouseParser.COMMA:
                self.state = 836
                self.match(ClickHouseParser.COMMA)
                self.state = 837
                self.table_ttl_declaration()
                self.state = 842
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Table_ttl_declarationContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ttlExpr = None  # ExprContext
            self.diskVal = None  # Token
            self.volumeVal = None  # Token

        def expr(self):
            return self.getTypedRuleContext(ClickHouseParser.ExprContext, 0)

        def K_DELETE(self):
            return self.getToken(ClickHouseParser.K_DELETE, 0)

        def K_TO(self):
            return self.getToken(ClickHouseParser.K_TO, 0)

        def K_DISK(self):
            return self.getToken(ClickHouseParser.K_DISK, 0)

        def K_VOLUME(self):
            return self.getToken(ClickHouseParser.K_VOLUME, 0)

        def STRING_LITERAL(self):
            return self.getToken(ClickHouseParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_table_ttl_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTable_ttl_declaration"):
                listener.enterTable_ttl_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTable_ttl_declaration"):
                listener.exitTable_ttl_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTable_ttl_declaration"):
                return visitor.visitTable_ttl_declaration(self)
            else:
                return visitor.visitChildren(self)

    def table_ttl_declaration(self):

        localctx = ClickHouseParser.Table_ttl_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_table_ttl_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 843
            localctx.ttlExpr = self.expr(0)
            self.state = 851
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 102, self._ctx)
            if la_ == 1:
                self.state = 844
                self.match(ClickHouseParser.K_DELETE)

            elif la_ == 2:
                self.state = 845
                self.match(ClickHouseParser.K_TO)
                self.state = 846
                self.match(ClickHouseParser.K_DISK)
                self.state = 847
                localctx.diskVal = self.match(ClickHouseParser.STRING_LITERAL)

            elif la_ == 3:
                self.state = 848
                self.match(ClickHouseParser.K_TO)
                self.state = 849
                self.match(ClickHouseParser.K_VOLUME)
                self.state = 850
                localctx.volumeVal = self.match(ClickHouseParser.STRING_LITERAL)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Nested_tableContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext, 0)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)

        def name_type_pair_list(self):
            return self.getTypedRuleContext(ClickHouseParser.Name_type_pair_listContext, 0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_nested_table

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNested_table"):
                listener.enterNested_table(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNested_table"):
                listener.exitNested_table(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNested_table"):
                return visitor.visitNested_table(self)
            else:
                return visitor.visitChildren(self)

    def nested_table(self):

        localctx = ClickHouseParser.Nested_tableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_nested_table)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 853
            self.identifier()
            self.state = 854
            self.match(ClickHouseParser.LPAREN)
            self.state = 855
            self.name_type_pair_list()
            self.state = 856
            self.match(ClickHouseParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Name_type_pair_listContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name_type_pair(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.Name_type_pairContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.Name_type_pairContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_name_type_pair_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterName_type_pair_list"):
                listener.enterName_type_pair_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitName_type_pair_list"):
                listener.exitName_type_pair_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitName_type_pair_list"):
                return visitor.visitName_type_pair_list(self)
            else:
                return visitor.visitChildren(self)

    def name_type_pair_list(self):

        localctx = ClickHouseParser.Name_type_pair_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_name_type_pair_list)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 858
            self.name_type_pair()
            self.state = 863
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ClickHouseParser.COMMA:
                self.state = 859
                self.match(ClickHouseParser.COMMA)
                self.state = 860
                self.name_type_pair()
                self.state = 865
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Name_type_pairContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext, 0)

        def column_type(self):
            return self.getTypedRuleContext(ClickHouseParser.Column_typeContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_name_type_pair

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterName_type_pair"):
                listener.enterName_type_pair(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitName_type_pair"):
                listener.exitName_type_pair(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitName_type_pair"):
                return visitor.visitName_type_pair(self)
            else:
                return visitor.visitChildren(self)

    def name_type_pair(self):

        localctx = ClickHouseParser.Name_type_pairContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_name_type_pair)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 866
            self.identifier()
            self.state = 867
            self.column_type()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Compound_name_type_pairContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def compound_identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.Compound_identifierContext, 0)

        def column_type(self):
            return self.getTypedRuleContext(ClickHouseParser.Column_typeContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_compound_name_type_pair

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCompound_name_type_pair"):
                listener.enterCompound_name_type_pair(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCompound_name_type_pair"):
                listener.exitCompound_name_type_pair(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCompound_name_type_pair"):
                return visitor.visitCompound_name_type_pair(self)
            else:
                return visitor.visitChildren(self)

    def compound_name_type_pair(self):

        localctx = ClickHouseParser.Compound_name_type_pairContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_compound_name_type_pair)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 869
            self.compound_identifier()
            self.state = 870
            self.column_type()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Column_declaration_listContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def column_declaration(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.Column_declarationContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.Column_declarationContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_column_declaration_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterColumn_declaration_list"):
                listener.enterColumn_declaration_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitColumn_declaration_list"):
                listener.exitColumn_declaration_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitColumn_declaration_list"):
                return visitor.visitColumn_declaration_list(self)
            else:
                return visitor.visitChildren(self)

    def column_declaration_list(self):

        localctx = ClickHouseParser.Column_declaration_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_column_declaration_list)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 872
            self.column_declaration()
            self.state = 877
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ClickHouseParser.COMMA:
                self.state = 873
                self.match(ClickHouseParser.COMMA)
                self.state = 874
                self.column_declaration()
                self.state = 879
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Column_declarationContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ttlExpr = None  # ExprContext

        def column_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Column_nameContext, 0)

        def column_type(self):
            return self.getTypedRuleContext(ClickHouseParser.Column_typeContext, 0)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ExprContext, i)

        def K_CODEC(self):
            return self.getToken(ClickHouseParser.K_CODEC, 0)

        def K_TTL(self):
            return self.getToken(ClickHouseParser.K_TTL, 0)

        def K_DEFAULT(self):
            return self.getToken(ClickHouseParser.K_DEFAULT, 0)

        def K_MATERIALIZED(self):
            return self.getToken(ClickHouseParser.K_MATERIALIZED, 0)

        def K_ALIAS(self):
            return self.getToken(ClickHouseParser.K_ALIAS, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_column_declaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterColumn_declaration"):
                listener.enterColumn_declaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitColumn_declaration"):
                listener.exitColumn_declaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitColumn_declaration"):
                return visitor.visitColumn_declaration(self)
            else:
                return visitor.visitChildren(self)

    def column_declaration(self):

        localctx = ClickHouseParser.Column_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_column_declaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 880
            self.column_name()
            self.state = 881
            self.column_type()
            self.state = 884
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la - 5)) & ~0x3F) == 0 and (
                (1 << (_la - 5))
                & (
                    (1 << (ClickHouseParser.K_ALIAS - 5))
                    | (1 << (ClickHouseParser.K_DEFAULT - 5))
                    | (1 << (ClickHouseParser.K_MATERIALIZED - 5))
                )
            ) != 0:
                self.state = 882
                _la = self._input.LA(1)
                if not (
                    (
                        (((_la - 5)) & ~0x3F) == 0
                        and (
                            (1 << (_la - 5))
                            & (
                                (1 << (ClickHouseParser.K_ALIAS - 5))
                                | (1 << (ClickHouseParser.K_DEFAULT - 5))
                                | (1 << (ClickHouseParser.K_MATERIALIZED - 5))
                            )
                        )
                        != 0
                    )
                ):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 883
                self.expr(0)

            self.state = 888
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_CODEC:
                self.state = 886
                self.match(ClickHouseParser.K_CODEC)

                self.state = 887
                self.expr(0)

            self.state = 892
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_TTL:
                self.state = 890
                self.match(ClickHouseParser.K_TTL)
                self.state = 891
                localctx.ttlExpr = self.expr(0)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Column_nameContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_column_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterColumn_name"):
                listener.enterColumn_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitColumn_name"):
                listener.exitColumn_name(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitColumn_name"):
                return visitor.visitColumn_name(self)
            else:
                return visitor.visitChildren(self)

    def column_name(self):

        localctx = ClickHouseParser.Column_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_column_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 894
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Column_typeContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def clickhouse_type(self):
            return self.getTypedRuleContext(ClickHouseParser.Clickhouse_typeContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_column_type

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterColumn_type"):
                listener.enterColumn_type(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitColumn_type"):
                listener.exitColumn_type(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitColumn_type"):
                return visitor.visitColumn_type(self)
            else:
                return visitor.visitChildren(self)

    def column_type(self):

        localctx = ClickHouseParser.Column_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_column_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 896
            self.clickhouse_type()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Column_name_listContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def column_name(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.Column_nameContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.Column_nameContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_column_name_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterColumn_name_list"):
                listener.enterColumn_name_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitColumn_name_list"):
                listener.exitColumn_name_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitColumn_name_list"):
                return visitor.visitColumn_name_list(self)
            else:
                return visitor.visitChildren(self)

    def column_name_list(self):

        localctx = ClickHouseParser.Column_name_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_column_name_list)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 898
            self.column_name()
            self.state = 903
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ClickHouseParser.COMMA:
                self.state = 899
                self.match(ClickHouseParser.COMMA)
                self.state = 900
                self.column_name()
                self.state = 905
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_expr_listContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.Select_exprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.Select_exprContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_select_expr_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelect_expr_list"):
                listener.enterSelect_expr_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelect_expr_list"):
                listener.exitSelect_expr_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSelect_expr_list"):
                return visitor.visitSelect_expr_list(self)
            else:
                return visitor.visitChildren(self)

    def select_expr_list(self):

        localctx = ClickHouseParser.Select_expr_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_select_expr_list)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 906
            self.select_expr()
            self.state = 911
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ClickHouseParser.COMMA:
                self.state = 907
                self.match(ClickHouseParser.COMMA)
                self.state = 908
                self.select_expr()
                self.state = 913
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_exprContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(ClickHouseParser.ExprContext, 0)

        def select_alias(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_aliasContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_select_expr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelect_expr"):
                listener.enterSelect_expr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelect_expr"):
                listener.exitSelect_expr(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSelect_expr"):
                return visitor.visitSelect_expr(self)
            else:
                return visitor.visitChildren(self)

    def select_expr(self):

        localctx = ClickHouseParser.Select_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_select_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 914
            self.expr(0)
            self.state = 916
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 110, self._ctx)
            if la_ == 1:
                self.state = 915
                self.select_alias()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_aliasContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def alias_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Alias_nameContext, 0)

        def K_AS(self):
            return self.getToken(ClickHouseParser.K_AS, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_select_alias

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelect_alias"):
                listener.enterSelect_alias(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelect_alias"):
                listener.exitSelect_alias(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSelect_alias"):
                return visitor.visitSelect_alias(self)
            else:
                return visitor.visitChildren(self)

    def select_alias(self):

        localctx = ClickHouseParser.Select_aliasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_select_alias)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 919
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 111, self._ctx)
            if la_ == 1:
                self.state = 918
                self.match(ClickHouseParser.K_AS)

            self.state = 921
            self.alias_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AliasContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_AS(self):
            return self.getToken(ClickHouseParser.K_AS, 0)

        def alias_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Alias_nameContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_alias

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAlias"):
                listener.enterAlias(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAlias"):
                listener.exitAlias(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAlias"):
                return visitor.visitAlias(self)
            else:
                return visitor.visitChildren(self)

    def alias(self):

        localctx = ClickHouseParser.AliasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_alias)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 923
            self.match(ClickHouseParser.K_AS)
            self.state = 924
            self.alias_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Alias_nameContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_alias_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAlias_name"):
                listener.enterAlias_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAlias_name"):
                listener.exitAlias_name(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAlias_name"):
                return visitor.visitAlias_name(self)
            else:
                return visitor.visitChildren(self)

    def alias_name(self):

        localctx = ClickHouseParser.Alias_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_alias_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 926
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Table_functionContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def function(self):
            return self.getTypedRuleContext(ClickHouseParser.FunctionContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_table_function

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTable_function"):
                listener.enterTable_function(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTable_function"):
                listener.exitTable_function(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTable_function"):
                return visitor.visitTable_function(self)
            else:
                return visitor.visitChildren(self)

    def table_function(self):

        localctx = ClickHouseParser.Table_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_table_function)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 928
            self.function()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SubqueryContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)

        def select_query_main(self):
            return self.getTypedRuleContext(ClickHouseParser.Select_query_mainContext, 0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_subquery

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSubquery"):
                listener.enterSubquery(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSubquery"):
                listener.exitSubquery(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSubquery"):
                return visitor.visitSubquery(self)
            else:
                return visitor.visitChildren(self)

    def subquery(self):

        localctx = ClickHouseParser.SubqueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_subquery)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 930
            self.match(ClickHouseParser.LPAREN)
            self.state = 931
            self.select_query_main()
            self.state = 932
            self.match(ClickHouseParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Expression_with_optional_aliasContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(ClickHouseParser.ExprContext, 0)

        def alias(self):
            return self.getTypedRuleContext(ClickHouseParser.AliasContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_expression_with_optional_alias

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpression_with_optional_alias"):
                listener.enterExpression_with_optional_alias(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpression_with_optional_alias"):
                listener.exitExpression_with_optional_alias(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpression_with_optional_alias"):
                return visitor.visitExpression_with_optional_alias(self)
            else:
                return visitor.visitChildren(self)

    def expression_with_optional_alias(self):

        localctx = ClickHouseParser.Expression_with_optional_aliasContext(
            self, self._ctx, self.state
        )
        self.enterRule(localctx, 140, self.RULE_expression_with_optional_alias)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 934
            self.expr(0)
            self.state = 936
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ClickHouseParser.K_AS:
                self.state = 935
                self.alias()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return ClickHouseParser.RULE_expr

        def copyFrom(self, ctx: ParserRuleContext):
            super().copyFrom(ctx)

    class ExprConcatContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ExprContext, i)

        def CONCAT(self):
            return self.getToken(ClickHouseParser.CONCAT, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprConcat"):
                listener.enterExprConcat(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprConcat"):
                listener.exitExprConcat(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprConcat"):
                return visitor.visitExprConcat(self)
            else:
                return visitor.visitChildren(self)

    class ExprCaseContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_CASE(self):
            return self.getToken(ClickHouseParser.K_CASE, 0)

        def K_ELSE(self):
            return self.getToken(ClickHouseParser.K_ELSE, 0)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ExprContext, i)

        def K_END(self):
            return self.getToken(ClickHouseParser.K_END, 0)

        def K_WHEN(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.K_WHEN)
            else:
                return self.getToken(ClickHouseParser.K_WHEN, i)

        def K_THEN(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.K_THEN)
            else:
                return self.getToken(ClickHouseParser.K_THEN, i)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprCase"):
                listener.enterExprCase(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprCase"):
                listener.exitExprCase(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprCase"):
                return visitor.visitExprCase(self)
            else:
                return visitor.visitChildren(self)

    class ExprTupleElementContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ExprContext, i)

        def DOT(self):
            return self.getToken(ClickHouseParser.DOT, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprTupleElement"):
                listener.enterExprTupleElement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprTupleElement"):
                listener.exitExprTupleElement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprTupleElement"):
                return visitor.visitExprTupleElement(self)
            else:
                return visitor.visitChildren(self)

    class ExprNotContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_NOT(self):
            return self.getToken(ClickHouseParser.K_NOT, 0)

        def expr(self):
            return self.getTypedRuleContext(ClickHouseParser.ExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprNot"):
                listener.enterExprNot(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprNot"):
                listener.exitExprNot(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprNot"):
                return visitor.visitExprNot(self)
            else:
                return visitor.visitChildren(self)

    class ExprArrayContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def array(self):
            return self.getTypedRuleContext(ClickHouseParser.ArrayContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprArray"):
                listener.enterExprArray(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprArray"):
                listener.exitExprArray(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprArray"):
                return visitor.visitExprArray(self)
            else:
                return visitor.visitChildren(self)

    class ExprWithAliasContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(ClickHouseParser.ExprContext, 0)

        def alias(self):
            return self.getTypedRuleContext(ClickHouseParser.AliasContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprWithAlias"):
                listener.enterExprWithAlias(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprWithAlias"):
                listener.exitExprWithAlias(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprWithAlias"):
                return visitor.visitExprWithAlias(self)
            else:
                return visitor.visitChildren(self)

    class ExprLogicalContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ExprContext, i)

        def EQUALS(self):
            return self.getToken(ClickHouseParser.EQUALS, 0)

        def ASSIGN(self):
            return self.getToken(ClickHouseParser.ASSIGN, 0)

        def NOT_EQUALS(self):
            return self.getToken(ClickHouseParser.NOT_EQUALS, 0)

        def NOT_EQUALS2(self):
            return self.getToken(ClickHouseParser.NOT_EQUALS2, 0)

        def LE(self):
            return self.getToken(ClickHouseParser.LE, 0)

        def GE(self):
            return self.getToken(ClickHouseParser.GE, 0)

        def LT(self):
            return self.getToken(ClickHouseParser.LT, 0)

        def GT(self):
            return self.getToken(ClickHouseParser.GT, 0)

        def K_LIKE(self):
            return self.getToken(ClickHouseParser.K_LIKE, 0)

        def K_NOT(self):
            return self.getToken(ClickHouseParser.K_NOT, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprLogical"):
                listener.enterExprLogical(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprLogical"):
                listener.exitExprLogical(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprLogical"):
                return visitor.visitExprLogical(self)
            else:
                return visitor.visitChildren(self)

    class ExprInContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ExprContext, i)

        def K_IN(self):
            return self.getToken(ClickHouseParser.K_IN, 0)

        def K_NOT(self):
            return self.getToken(ClickHouseParser.K_NOT, 0)

        def K_GLOBAL(self):
            return self.getToken(ClickHouseParser.K_GLOBAL, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprIn"):
                listener.enterExprIn(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprIn"):
                listener.exitExprIn(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprIn"):
                return visitor.visitExprIn(self)
            else:
                return visitor.visitChildren(self)

    class ExprCastContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_CAST(self):
            return self.getToken(ClickHouseParser.K_CAST, 0)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)

        def expr(self):
            return self.getTypedRuleContext(ClickHouseParser.ExprContext, 0)

        def K_AS(self):
            return self.getToken(ClickHouseParser.K_AS, 0)

        def clickhouse_type(self):
            return self.getTypedRuleContext(ClickHouseParser.Clickhouse_typeContext, 0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprCast"):
                listener.enterExprCast(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprCast"):
                listener.exitExprCast(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprCast"):
                return visitor.visitExprCast(self)
            else:
                return visitor.visitChildren(self)

    class ExprOrContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ExprContext, i)

        def K_OR(self):
            return self.getToken(ClickHouseParser.K_OR, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprOr"):
                listener.enterExprOr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprOr"):
                listener.exitExprOr(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprOr"):
                return visitor.visitExprOr(self)
            else:
                return visitor.visitChildren(self)

    class ExprFunctionContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def function(self):
            return self.getTypedRuleContext(ClickHouseParser.FunctionContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprFunction"):
                listener.enterExprFunction(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprFunction"):
                listener.exitExprFunction(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprFunction"):
                return visitor.visitExprFunction(self)
            else:
                return visitor.visitChildren(self)

    class ExprMulContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ExprContext, i)

        def STAR(self):
            return self.getToken(ClickHouseParser.STAR, 0)

        def DIVIDE(self):
            return self.getToken(ClickHouseParser.DIVIDE, 0)

        def PERCENT(self):
            return self.getToken(ClickHouseParser.PERCENT, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprMul"):
                listener.enterExprMul(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprMul"):
                listener.exitExprMul(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprMul"):
                return visitor.visitExprMul(self)
            else:
                return visitor.visitChildren(self)

    class ExprIdContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def compound_identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.Compound_identifierContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprId"):
                listener.enterExprId(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprId"):
                listener.exitExprId(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprId"):
                return visitor.visitExprId(self)
            else:
                return visitor.visitChildren(self)

    class ExprLambdaContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def RARROW(self):
            return self.getToken(ClickHouseParser.RARROW, 0)

        def expr(self):
            return self.getTypedRuleContext(ClickHouseParser.ExprContext, 0)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)

        def identifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.IdentifierContext, i)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprLambda"):
                listener.enterExprLambda(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprLambda"):
                listener.exitExprLambda(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprLambda"):
                return visitor.visitExprLambda(self)
            else:
                return visitor.visitChildren(self)

    class ExprTernaryContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ExprContext, i)

        def QUESTION(self):
            return self.getToken(ClickHouseParser.QUESTION, 0)

        def COLON(self):
            return self.getToken(ClickHouseParser.COLON, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprTernary"):
                listener.enterExprTernary(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprTernary"):
                listener.exitExprTernary(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprTernary"):
                return visitor.visitExprTernary(self)
            else:
                return visitor.visitChildren(self)

    class ExprParenContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)

        def expr(self):
            return self.getTypedRuleContext(ClickHouseParser.ExprContext, 0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprParen"):
                listener.enterExprParen(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprParen"):
                listener.exitExprParen(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprParen"):
                return visitor.visitExprParen(self)
            else:
                return visitor.visitChildren(self)

    class ExprBetweenContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ExprContext, i)

        def K_BETWEEN(self):
            return self.getToken(ClickHouseParser.K_BETWEEN, 0)

        def K_AND(self):
            return self.getToken(ClickHouseParser.K_AND, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprBetween"):
                listener.enterExprBetween(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprBetween"):
                listener.exitExprBetween(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprBetween"):
                return visitor.visitExprBetween(self)
            else:
                return visitor.visitChildren(self)

    class ExprSubqueryContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def subquery(self):
            return self.getTypedRuleContext(ClickHouseParser.SubqueryContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprSubquery"):
                listener.enterExprSubquery(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprSubquery"):
                listener.exitExprSubquery(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprSubquery"):
                return visitor.visitExprSubquery(self)
            else:
                return visitor.visitChildren(self)

    class ExprStarContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STAR(self):
            return self.getToken(ClickHouseParser.STAR, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprStar"):
                listener.enterExprStar(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprStar"):
                listener.exitExprStar(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprStar"):
                return visitor.visitExprStar(self)
            else:
                return visitor.visitChildren(self)

    class ExprIntervalContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def K_INTERVAL(self):
            return self.getToken(ClickHouseParser.K_INTERVAL, 0)

        def expr(self):
            return self.getTypedRuleContext(ClickHouseParser.ExprContext, 0)

        def interval_unit(self):
            return self.getTypedRuleContext(ClickHouseParser.Interval_unitContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprInterval"):
                listener.enterExprInterval(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprInterval"):
                listener.exitExprInterval(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprInterval"):
                return visitor.visitExprInterval(self)
            else:
                return visitor.visitChildren(self)

    class ExprAndContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ExprContext, i)

        def K_AND(self):
            return self.getToken(ClickHouseParser.K_AND, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprAnd"):
                listener.enterExprAnd(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprAnd"):
                listener.exitExprAnd(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprAnd"):
                return visitor.visitExprAnd(self)
            else:
                return visitor.visitChildren(self)

    class ExprArrayElementContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ExprContext, i)

        def LBRAKET(self):
            return self.getToken(ClickHouseParser.LBRAKET, 0)

        def RBRAKET(self):
            return self.getToken(ClickHouseParser.RBRAKET, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprArrayElement"):
                listener.enterExprArrayElement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprArrayElement"):
                listener.exitExprArrayElement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprArrayElement"):
                return visitor.visitExprArrayElement(self)
            else:
                return visitor.visitChildren(self)

    class ExprIsNullContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(ClickHouseParser.ExprContext, 0)

        def K_IS(self):
            return self.getToken(ClickHouseParser.K_IS, 0)

        def K_NULL(self):
            return self.getToken(ClickHouseParser.K_NULL, 0)

        def K_NOT(self):
            return self.getToken(ClickHouseParser.K_NOT, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprIsNull"):
                listener.enterExprIsNull(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprIsNull"):
                listener.exitExprIsNull(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprIsNull"):
                return visitor.visitExprIsNull(self)
            else:
                return visitor.visitChildren(self)

    class ExprListContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)

        def not_empty_expression_list(self):
            return self.getTypedRuleContext(ClickHouseParser.Not_empty_expression_listContext, 0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprList"):
                listener.enterExprList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprList"):
                listener.exitExprList(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprList"):
                return visitor.visitExprList(self)
            else:
                return visitor.visitChildren(self)

    class ExprLiteralContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def literal(self):
            return self.getTypedRuleContext(ClickHouseParser.LiteralContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprLiteral"):
                listener.enterExprLiteral(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprLiteral"):
                listener.exitExprLiteral(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprLiteral"):
                return visitor.visitExprLiteral(self)
            else:
                return visitor.visitChildren(self)

    class ExprUnaryMinusContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MINUS(self):
            return self.getToken(ClickHouseParser.MINUS, 0)

        def expr(self):
            return self.getTypedRuleContext(ClickHouseParser.ExprContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprUnaryMinus"):
                listener.enterExprUnaryMinus(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprUnaryMinus"):
                listener.exitExprUnaryMinus(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprUnaryMinus"):
                return visitor.visitExprUnaryMinus(self)
            else:
                return visitor.visitChildren(self)

    class ExprAddContext(ExprContext):
        def __init__(
            self, parser, ctx: ParserRuleContext
        ):  # actually a ClickHouseParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ExprContext, i)

        def PLUS(self):
            return self.getToken(ClickHouseParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(ClickHouseParser.MINUS, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExprAdd"):
                listener.enterExprAdd(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExprAdd"):
                listener.exitExprAdd(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExprAdd"):
                return visitor.visitExprAdd(self)
            else:
                return visitor.visitChildren(self)

    def expr(self, _p: int = 0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = ClickHouseParser.ExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 142
        self.enterRecursionRule(localctx, 142, self.RULE_expr, _p)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1015
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 118, self._ctx)
            if la_ == 1:
                localctx = ClickHouseParser.ExprParenContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 939
                self.match(ClickHouseParser.LPAREN)
                self.state = 940
                self.expr(0)
                self.state = 941
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = ClickHouseParser.ExprFunctionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 943
                self.function()
                pass

            elif la_ == 3:
                localctx = ClickHouseParser.ExprCaseContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 944
                self.match(ClickHouseParser.K_CASE)
                self.state = 946
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 113, self._ctx)
                if la_ == 1:
                    self.state = 945
                    self.expr(0)

                self.state = 948
                self.match(ClickHouseParser.K_WHEN)
                self.state = 949
                self.expr(0)
                self.state = 950
                self.match(ClickHouseParser.K_THEN)
                self.state = 951
                self.expr(0)
                self.state = 960
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == ClickHouseParser.K_WHEN:
                    self.state = 953
                    self.match(ClickHouseParser.K_WHEN)
                    self.state = 954
                    self.expr(0)
                    self.state = 955
                    self.match(ClickHouseParser.K_THEN)
                    self.state = 956
                    self.expr(0)
                    self.state = 962
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 963
                self.match(ClickHouseParser.K_ELSE)
                self.state = 964
                self.expr(0)
                self.state = 965
                self.match(ClickHouseParser.K_END)
                pass

            elif la_ == 4:
                localctx = ClickHouseParser.ExprUnaryMinusContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 967
                self.match(ClickHouseParser.MINUS)
                self.state = 968
                self.expr(22)
                pass

            elif la_ == 5:
                localctx = ClickHouseParser.ExprCastContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 969
                self.match(ClickHouseParser.K_CAST)
                self.state = 970
                self.match(ClickHouseParser.LPAREN)
                self.state = 971
                self.expr(0)
                self.state = 972
                self.match(ClickHouseParser.K_AS)
                self.state = 973
                self.clickhouse_type()
                self.state = 974
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 6:
                localctx = ClickHouseParser.ExprIntervalContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 976
                self.match(ClickHouseParser.K_INTERVAL)
                self.state = 977
                self.expr(0)
                self.state = 978
                self.interval_unit()
                pass

            elif la_ == 7:
                localctx = ClickHouseParser.ExprNotContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 980
                self.match(ClickHouseParser.K_NOT)
                self.state = 981
                self.expr(12)
                pass

            elif la_ == 8:
                localctx = ClickHouseParser.ExprLambdaContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1001
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [ClickHouseParser.LPAREN]:
                    self.state = 982
                    self.match(ClickHouseParser.LPAREN)
                    self.state = 983
                    self.identifier()
                    self.state = 988
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la == ClickHouseParser.COMMA:
                        self.state = 984
                        self.match(ClickHouseParser.COMMA)
                        self.state = 985
                        self.identifier()
                        self.state = 990
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 991
                    self.match(ClickHouseParser.RPAREN)
                    pass
                elif token in [
                    ClickHouseParser.K_ADD,
                    ClickHouseParser.K_AFTER,
                    ClickHouseParser.K_ALL,
                    ClickHouseParser.K_ALIAS,
                    ClickHouseParser.K_ALTER,
                    ClickHouseParser.K_AND,
                    ClickHouseParser.K_ANY,
                    ClickHouseParser.K_ARRAY,
                    ClickHouseParser.K_AS,
                    ClickHouseParser.K_ASCENDING,
                    ClickHouseParser.K_ASC,
                    ClickHouseParser.K_ASYNC,
                    ClickHouseParser.K_ATTACH,
                    ClickHouseParser.K_BETWEEN,
                    ClickHouseParser.K_BY,
                    ClickHouseParser.K_CASE,
                    ClickHouseParser.K_CHECK,
                    ClickHouseParser.K_COLUMN,
                    ClickHouseParser.K_COLLATE,
                    ClickHouseParser.K_CREATE,
                    ClickHouseParser.K_CROSS,
                    ClickHouseParser.K_DESCRIBE,
                    ClickHouseParser.K_DESCENDING,
                    ClickHouseParser.K_DESC,
                    ClickHouseParser.K_DATABASE,
                    ClickHouseParser.K_DATABASES,
                    ClickHouseParser.K_DEFAULT,
                    ClickHouseParser.K_DETACH,
                    ClickHouseParser.K_DISTINCT,
                    ClickHouseParser.K_DROP,
                    ClickHouseParser.K_ELSE,
                    ClickHouseParser.K_END,
                    ClickHouseParser.K_ENGINE,
                    ClickHouseParser.K_EXISTS,
                    ClickHouseParser.K_FINAL,
                    ClickHouseParser.K_FIRST,
                    ClickHouseParser.K_FROM,
                    ClickHouseParser.K_FORMAT,
                    ClickHouseParser.K_FULL,
                    ClickHouseParser.K_GLOBAL,
                    ClickHouseParser.K_GROUP,
                    ClickHouseParser.K_HAVING,
                    ClickHouseParser.K_ID,
                    ClickHouseParser.K_IF,
                    ClickHouseParser.K_INNER,
                    ClickHouseParser.K_INSERT,
                    ClickHouseParser.K_INTO,
                    ClickHouseParser.K_IN,
                    ClickHouseParser.K_IS,
                    ClickHouseParser.K_JOIN,
                    ClickHouseParser.K_KILL,
                    ClickHouseParser.K_LAST,
                    ClickHouseParser.K_LEFT,
                    ClickHouseParser.K_LIKE,
                    ClickHouseParser.K_LIMIT,
                    ClickHouseParser.K_MAIN,
                    ClickHouseParser.K_MATERIALIZED,
                    ClickHouseParser.K_MODIFY,
                    ClickHouseParser.K_NOT,
                    ClickHouseParser.K_NULL,
                    ClickHouseParser.K_NULLS,
                    ClickHouseParser.K_OFFSET,
                    ClickHouseParser.K_ON,
                    ClickHouseParser.K_OPTIMIZE,
                    ClickHouseParser.K_ORDER,
                    ClickHouseParser.K_OR,
                    ClickHouseParser.K_OUTFILE,
                    ClickHouseParser.K_PARTITION,
                    ClickHouseParser.K_POPULATE,
                    ClickHouseParser.K_PREWHERE,
                    ClickHouseParser.K_PROCESSLIST,
                    ClickHouseParser.K_QUERY,
                    ClickHouseParser.K_RENAME,
                    ClickHouseParser.K_RETURN,
                    ClickHouseParser.K_RIGHT,
                    ClickHouseParser.K_SAMPLE,
                    ClickHouseParser.K_SELECT,
                    ClickHouseParser.K_SET,
                    ClickHouseParser.K_SETTINGS,
                    ClickHouseParser.K_SHOW,
                    ClickHouseParser.K_SYNC,
                    ClickHouseParser.K_TABLE,
                    ClickHouseParser.K_TABLES,
                    ClickHouseParser.K_TEMPORARY,
                    ClickHouseParser.K_TEST,
                    ClickHouseParser.K_THEN,
                    ClickHouseParser.K_TOTALS,
                    ClickHouseParser.K_TO,
                    ClickHouseParser.K_OUTER,
                    ClickHouseParser.K_VALUES,
                    ClickHouseParser.K_VIEW,
                    ClickHouseParser.K_UNION,
                    ClickHouseParser.K_USE,
                    ClickHouseParser.K_USING,
                    ClickHouseParser.K_WHEN,
                    ClickHouseParser.K_WHERE,
                    ClickHouseParser.K_WITH,
                    ClickHouseParser.T_FLOAT32,
                    ClickHouseParser.T_FLOAT64,
                    ClickHouseParser.T_UINT8,
                    ClickHouseParser.T_UINT16,
                    ClickHouseParser.T_UINT32,
                    ClickHouseParser.T_UINT64,
                    ClickHouseParser.T_INT8,
                    ClickHouseParser.T_INT16,
                    ClickHouseParser.T_INT32,
                    ClickHouseParser.T_INT64,
                    ClickHouseParser.T_ENUM8,
                    ClickHouseParser.T_ENUM16,
                    ClickHouseParser.T_UUID,
                    ClickHouseParser.T_DATE,
                    ClickHouseParser.T_DATETIME,
                    ClickHouseParser.T_STRING,
                    ClickHouseParser.T_FIXEDSTRING,
                    ClickHouseParser.T_NULL,
                    ClickHouseParser.T_INTERVAL_YEAR,
                    ClickHouseParser.T_INTERVAL_MONTH,
                    ClickHouseParser.T_INTERVAL_WEEK,
                    ClickHouseParser.T_INTERVAL_DAY,
                    ClickHouseParser.T_INTERVAL_HOUR,
                    ClickHouseParser.T_INTERVAL_MINUTE,
                    ClickHouseParser.T_INTERVAL_SECOND,
                    ClickHouseParser.IDENTIFIER,
                    ClickHouseParser.QUOTED_LITERAL,
                ]:
                    self.state = 993
                    self.identifier()
                    self.state = 998
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la == ClickHouseParser.COMMA:
                        self.state = 994
                        self.match(ClickHouseParser.COMMA)
                        self.state = 995
                        self.identifier()
                        self.state = 1000
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1003
                self.match(ClickHouseParser.RARROW)
                self.state = 1004
                self.expr(8)
                pass

            elif la_ == 9:
                localctx = ClickHouseParser.ExprSubqueryContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1006
                self.subquery()
                pass

            elif la_ == 10:
                localctx = ClickHouseParser.ExprListContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1007
                self.match(ClickHouseParser.LPAREN)
                self.state = 1008
                self.not_empty_expression_list()
                self.state = 1009
                self.match(ClickHouseParser.RPAREN)
                pass

            elif la_ == 11:
                localctx = ClickHouseParser.ExprArrayContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1011
                self.array()
                pass

            elif la_ == 12:
                localctx = ClickHouseParser.ExprLiteralContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1012
                self.literal()
                pass

            elif la_ == 13:
                localctx = ClickHouseParser.ExprIdContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1013
                self.compound_identifier()
                pass

            elif la_ == 14:
                localctx = ClickHouseParser.ExprStarContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1014
                self.match(ClickHouseParser.STAR)
                pass

            self._ctx.stop = self._input.LT(-1)
            self.state = 1091
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 123, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 1089
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 122, self._ctx)
                    if la_ == 1:
                        localctx = ClickHouseParser.ExprTupleElementContext(
                            self, ClickHouseParser.ExprContext(self, _parentctx, _parentState)
                        )
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 1017
                        if not self.precpred(self._ctx, 24):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 24)")
                        self.state = 1018
                        self.match(ClickHouseParser.DOT)
                        self.state = 1019
                        self.expr(25)
                        pass

                    elif la_ == 2:
                        localctx = ClickHouseParser.ExprMulContext(
                            self, ClickHouseParser.ExprContext(self, _parentctx, _parentState)
                        )
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 1020
                        if not self.precpred(self._ctx, 20):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 20)")
                        self.state = 1021
                        _la = self._input.LA(1)
                        if not (
                            (
                                (((_la - 125)) & ~0x3F) == 0
                                and (
                                    (1 << (_la - 125))
                                    & (
                                        (1 << (ClickHouseParser.STAR - 125))
                                        | (1 << (ClickHouseParser.PERCENT - 125))
                                        | (1 << (ClickHouseParser.DIVIDE - 125))
                                    )
                                )
                                != 0
                            )
                        ):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1022
                        self.expr(21)
                        pass

                    elif la_ == 3:
                        localctx = ClickHouseParser.ExprAddContext(
                            self, ClickHouseParser.ExprContext(self, _parentctx, _parentState)
                        )
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 1023
                        if not self.precpred(self._ctx, 19):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 19)")
                        self.state = 1024
                        _la = self._input.LA(1)
                        if not (_la == ClickHouseParser.PLUS or _la == ClickHouseParser.MINUS):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1025
                        self.expr(20)
                        pass

                    elif la_ == 4:
                        localctx = ClickHouseParser.ExprConcatContext(
                            self, ClickHouseParser.ExprContext(self, _parentctx, _parentState)
                        )
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 1026
                        if not self.precpred(self._ctx, 18):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 18)")
                        self.state = 1027
                        self.match(ClickHouseParser.CONCAT)
                        self.state = 1028
                        self.expr(19)
                        pass

                    elif la_ == 5:
                        localctx = ClickHouseParser.ExprBetweenContext(
                            self, ClickHouseParser.ExprContext(self, _parentctx, _parentState)
                        )
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 1029
                        if not self.precpred(self._ctx, 17):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 17)")
                        self.state = 1030
                        self.match(ClickHouseParser.K_BETWEEN)
                        self.state = 1031
                        self.expr(0)
                        self.state = 1032
                        self.match(ClickHouseParser.K_AND)
                        self.state = 1033
                        self.expr(18)
                        pass

                    elif la_ == 6:
                        localctx = ClickHouseParser.ExprLogicalContext(
                            self, ClickHouseParser.ExprContext(self, _parentctx, _parentState)
                        )
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 1035
                        if not self.precpred(self._ctx, 16):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
                        self.state = 1047
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [ClickHouseParser.EQUALS]:
                            self.state = 1036
                            self.match(ClickHouseParser.EQUALS)
                            pass
                        elif token in [ClickHouseParser.ASSIGN]:
                            self.state = 1037
                            self.match(ClickHouseParser.ASSIGN)
                            pass
                        elif token in [ClickHouseParser.NOT_EQUALS]:
                            self.state = 1038
                            self.match(ClickHouseParser.NOT_EQUALS)
                            pass
                        elif token in [ClickHouseParser.NOT_EQUALS2]:
                            self.state = 1039
                            self.match(ClickHouseParser.NOT_EQUALS2)
                            pass
                        elif token in [ClickHouseParser.LE]:
                            self.state = 1040
                            self.match(ClickHouseParser.LE)
                            pass
                        elif token in [ClickHouseParser.GE]:
                            self.state = 1041
                            self.match(ClickHouseParser.GE)
                            pass
                        elif token in [ClickHouseParser.LT]:
                            self.state = 1042
                            self.match(ClickHouseParser.LT)
                            pass
                        elif token in [ClickHouseParser.GT]:
                            self.state = 1043
                            self.match(ClickHouseParser.GT)
                            pass
                        elif token in [ClickHouseParser.K_LIKE]:
                            self.state = 1044
                            self.match(ClickHouseParser.K_LIKE)
                            pass
                        elif token in [ClickHouseParser.K_NOT]:
                            self.state = 1045
                            self.match(ClickHouseParser.K_NOT)
                            self.state = 1046
                            self.match(ClickHouseParser.K_LIKE)
                            pass
                        else:
                            raise NoViableAltException(self)

                        self.state = 1049
                        self.expr(17)
                        pass

                    elif la_ == 7:
                        localctx = ClickHouseParser.ExprInContext(
                            self, ClickHouseParser.ExprContext(self, _parentctx, _parentState)
                        )
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 1050
                        if not self.precpred(self._ctx, 15):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
                        self.state = 1059
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input, 120, self._ctx)
                        if la_ == 1:
                            self.state = 1051
                            self.match(ClickHouseParser.K_IN)
                            pass

                        elif la_ == 2:
                            self.state = 1052
                            self.match(ClickHouseParser.K_NOT)
                            self.state = 1053
                            self.match(ClickHouseParser.K_IN)
                            pass

                        elif la_ == 3:
                            self.state = 1054
                            self.match(ClickHouseParser.K_GLOBAL)
                            self.state = 1055
                            self.match(ClickHouseParser.K_IN)
                            pass

                        elif la_ == 4:
                            self.state = 1056
                            self.match(ClickHouseParser.K_GLOBAL)
                            self.state = 1057
                            self.match(ClickHouseParser.K_NOT)
                            self.state = 1058
                            self.match(ClickHouseParser.K_IN)
                            pass

                        self.state = 1061
                        self.expr(16)
                        pass

                    elif la_ == 8:
                        localctx = ClickHouseParser.ExprAndContext(
                            self, ClickHouseParser.ExprContext(self, _parentctx, _parentState)
                        )
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 1062
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 1063
                        self.match(ClickHouseParser.K_AND)
                        self.state = 1064
                        self.expr(12)
                        pass

                    elif la_ == 9:
                        localctx = ClickHouseParser.ExprOrContext(
                            self, ClickHouseParser.ExprContext(self, _parentctx, _parentState)
                        )
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 1065
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 1066
                        self.match(ClickHouseParser.K_OR)
                        self.state = 1067
                        self.expr(11)
                        pass

                    elif la_ == 10:
                        localctx = ClickHouseParser.ExprTernaryContext(
                            self, ClickHouseParser.ExprContext(self, _parentctx, _parentState)
                        )
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 1068
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 1069
                        self.match(ClickHouseParser.QUESTION)
                        self.state = 1070
                        self.expr(0)
                        self.state = 1071
                        self.match(ClickHouseParser.COLON)
                        self.state = 1072
                        self.expr(10)
                        pass

                    elif la_ == 11:
                        localctx = ClickHouseParser.ExprArrayElementContext(
                            self, ClickHouseParser.ExprContext(self, _parentctx, _parentState)
                        )
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 1074
                        if not self.precpred(self._ctx, 23):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 23)")
                        self.state = 1075
                        self.match(ClickHouseParser.LBRAKET)
                        self.state = 1076
                        self.expr(0)
                        self.state = 1077
                        self.match(ClickHouseParser.RBRAKET)
                        pass

                    elif la_ == 12:
                        localctx = ClickHouseParser.ExprIsNullContext(
                            self, ClickHouseParser.ExprContext(self, _parentctx, _parentState)
                        )
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 1079
                        if not self.precpred(self._ctx, 14):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
                        self.state = 1085
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input, 121, self._ctx)
                        if la_ == 1:
                            self.state = 1080
                            self.match(ClickHouseParser.K_IS)
                            self.state = 1081
                            self.match(ClickHouseParser.K_NULL)
                            pass

                        elif la_ == 2:
                            self.state = 1082
                            self.match(ClickHouseParser.K_IS)
                            self.state = 1083
                            self.match(ClickHouseParser.K_NOT)
                            self.state = 1084
                            self.match(ClickHouseParser.K_NULL)
                            pass

                        pass

                    elif la_ == 13:
                        localctx = ClickHouseParser.ExprWithAliasContext(
                            self, ClickHouseParser.ExprContext(self, _parentctx, _parentState)
                        )
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 1087
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 1088
                        self.alias()
                        pass

                self.state = 1093
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 123, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Interval_unitContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_YEAR(self):
            return self.getToken(ClickHouseParser.K_YEAR, 0)

        def K_MONTH(self):
            return self.getToken(ClickHouseParser.K_MONTH, 0)

        def K_WEEK(self):
            return self.getToken(ClickHouseParser.K_WEEK, 0)

        def K_DAY(self):
            return self.getToken(ClickHouseParser.K_DAY, 0)

        def K_HOUR(self):
            return self.getToken(ClickHouseParser.K_HOUR, 0)

        def K_MINUTE(self):
            return self.getToken(ClickHouseParser.K_MINUTE, 0)

        def K_SECOND(self):
            return self.getToken(ClickHouseParser.K_SECOND, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_interval_unit

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterval_unit"):
                listener.enterInterval_unit(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterval_unit"):
                listener.exitInterval_unit(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterval_unit"):
                return visitor.visitInterval_unit(self)
            else:
                return visitor.visitChildren(self)

    def interval_unit(self):

        localctx = ClickHouseParser.Interval_unitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_interval_unit)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1094
            _la = self._input.LA(1)
            if not (
                _la == ClickHouseParser.K_DAY
                or _la == ClickHouseParser.K_HOUR
                or (
                    (((_la - 69)) & ~0x3F) == 0
                    and (
                        (1 << (_la - 69))
                        & (
                            (1 << (ClickHouseParser.K_MINUTE - 69))
                            | (1 << (ClickHouseParser.K_MONTH - 69))
                            | (1 << (ClickHouseParser.K_SECOND - 69))
                            | (1 << (ClickHouseParser.K_WEEK - 69))
                            | (1 << (ClickHouseParser.K_YEAR - 69))
                        )
                    )
                    != 0
                )
            ):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Expression_listContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def not_empty_expression_list(self):
            return self.getTypedRuleContext(ClickHouseParser.Not_empty_expression_listContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_expression_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpression_list"):
                listener.enterExpression_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpression_list"):
                listener.exitExpression_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpression_list"):
                return visitor.visitExpression_list(self)
            else:
                return visitor.visitChildren(self)

    def expression_list(self):

        localctx = ClickHouseParser.Expression_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_expression_list)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1097
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (
                (
                    ((_la) & ~0x3F) == 0
                    and (
                        (1 << _la)
                        & (
                            (1 << ClickHouseParser.K_ADD)
                            | (1 << ClickHouseParser.K_AFTER)
                            | (1 << ClickHouseParser.K_ALL)
                            | (1 << ClickHouseParser.K_ALIAS)
                            | (1 << ClickHouseParser.K_ALTER)
                            | (1 << ClickHouseParser.K_AND)
                            | (1 << ClickHouseParser.K_ANY)
                            | (1 << ClickHouseParser.K_ARRAY)
                            | (1 << ClickHouseParser.K_AS)
                            | (1 << ClickHouseParser.K_ASCENDING)
                            | (1 << ClickHouseParser.K_ASC)
                            | (1 << ClickHouseParser.K_ASYNC)
                            | (1 << ClickHouseParser.K_ATTACH)
                            | (1 << ClickHouseParser.K_BETWEEN)
                            | (1 << ClickHouseParser.K_BY)
                            | (1 << ClickHouseParser.K_CASE)
                            | (1 << ClickHouseParser.K_CAST)
                            | (1 << ClickHouseParser.K_CHECK)
                            | (1 << ClickHouseParser.K_COLUMN)
                            | (1 << ClickHouseParser.K_COLLATE)
                            | (1 << ClickHouseParser.K_CREATE)
                            | (1 << ClickHouseParser.K_CROSS)
                            | (1 << ClickHouseParser.K_DESCRIBE)
                            | (1 << ClickHouseParser.K_DESCENDING)
                            | (1 << ClickHouseParser.K_DESC)
                            | (1 << ClickHouseParser.K_DATABASE)
                            | (1 << ClickHouseParser.K_DATABASES)
                            | (1 << ClickHouseParser.K_DEFAULT)
                            | (1 << ClickHouseParser.K_DETACH)
                            | (1 << ClickHouseParser.K_DISTINCT)
                            | (1 << ClickHouseParser.K_DROP)
                            | (1 << ClickHouseParser.K_ELSE)
                            | (1 << ClickHouseParser.K_END)
                            | (1 << ClickHouseParser.K_ENGINE)
                            | (1 << ClickHouseParser.K_EXISTS)
                            | (1 << ClickHouseParser.K_FINAL)
                            | (1 << ClickHouseParser.K_FIRST)
                            | (1 << ClickHouseParser.K_FROM)
                            | (1 << ClickHouseParser.K_FORMAT)
                            | (1 << ClickHouseParser.K_FULL)
                            | (1 << ClickHouseParser.K_GLOBAL)
                            | (1 << ClickHouseParser.K_GROUP)
                            | (1 << ClickHouseParser.K_HAVING)
                            | (1 << ClickHouseParser.K_ID)
                            | (1 << ClickHouseParser.K_IF)
                            | (1 << ClickHouseParser.K_INNER)
                            | (1 << ClickHouseParser.K_INSERT)
                            | (1 << ClickHouseParser.K_INTERVAL)
                            | (1 << ClickHouseParser.K_INTO)
                            | (1 << ClickHouseParser.K_IN)
                            | (1 << ClickHouseParser.K_IS)
                            | (1 << ClickHouseParser.K_JOIN)
                            | (1 << ClickHouseParser.K_KILL)
                            | (1 << ClickHouseParser.K_LAST)
                        )
                    )
                    != 0
                )
                or (
                    (((_la - 64)) & ~0x3F) == 0
                    and (
                        (1 << (_la - 64))
                        & (
                            (1 << (ClickHouseParser.K_LEFT - 64))
                            | (1 << (ClickHouseParser.K_LIKE - 64))
                            | (1 << (ClickHouseParser.K_LIMIT - 64))
                            | (1 << (ClickHouseParser.K_MAIN - 64))
                            | (1 << (ClickHouseParser.K_MATERIALIZED - 64))
                            | (1 << (ClickHouseParser.K_MODIFY - 64))
                            | (1 << (ClickHouseParser.K_NOT - 64))
                            | (1 << (ClickHouseParser.K_NULL - 64))
                            | (1 << (ClickHouseParser.K_NULLS - 64))
                            | (1 << (ClickHouseParser.K_OFFSET - 64))
                            | (1 << (ClickHouseParser.K_ON - 64))
                            | (1 << (ClickHouseParser.K_OPTIMIZE - 64))
                            | (1 << (ClickHouseParser.K_ORDER - 64))
                            | (1 << (ClickHouseParser.K_OR - 64))
                            | (1 << (ClickHouseParser.K_OUTFILE - 64))
                            | (1 << (ClickHouseParser.K_PARTITION - 64))
                            | (1 << (ClickHouseParser.K_POPULATE - 64))
                            | (1 << (ClickHouseParser.K_PREWHERE - 64))
                            | (1 << (ClickHouseParser.K_PROCESSLIST - 64))
                            | (1 << (ClickHouseParser.K_QUERY - 64))
                            | (1 << (ClickHouseParser.K_RENAME - 64))
                            | (1 << (ClickHouseParser.K_RETURN - 64))
                            | (1 << (ClickHouseParser.K_RIGHT - 64))
                            | (1 << (ClickHouseParser.K_SAMPLE - 64))
                            | (1 << (ClickHouseParser.K_SELECT - 64))
                            | (1 << (ClickHouseParser.K_SET - 64))
                            | (1 << (ClickHouseParser.K_SETTINGS - 64))
                            | (1 << (ClickHouseParser.K_SHOW - 64))
                            | (1 << (ClickHouseParser.K_SYNC - 64))
                            | (1 << (ClickHouseParser.K_TABLE - 64))
                            | (1 << (ClickHouseParser.K_TABLES - 64))
                            | (1 << (ClickHouseParser.K_TEMPORARY - 64))
                            | (1 << (ClickHouseParser.K_TEST - 64))
                            | (1 << (ClickHouseParser.K_THEN - 64))
                            | (1 << (ClickHouseParser.K_TOTALS - 64))
                            | (1 << (ClickHouseParser.K_TO - 64))
                            | (1 << (ClickHouseParser.K_OUTER - 64))
                            | (1 << (ClickHouseParser.K_VALUES - 64))
                            | (1 << (ClickHouseParser.K_VIEW - 64))
                            | (1 << (ClickHouseParser.K_UNION - 64))
                            | (1 << (ClickHouseParser.K_USE - 64))
                            | (1 << (ClickHouseParser.K_USING - 64))
                            | (1 << (ClickHouseParser.K_WHEN - 64))
                            | (1 << (ClickHouseParser.K_WHERE - 64))
                            | (1 << (ClickHouseParser.K_WITH - 64))
                            | (1 << (ClickHouseParser.LPAREN - 64))
                            | (1 << (ClickHouseParser.STAR - 64))
                        )
                    )
                    != 0
                )
                or (
                    (((_la - 132)) & ~0x3F) == 0
                    and (
                        (1 << (_la - 132))
                        & (
                            (1 << (ClickHouseParser.MINUS - 132))
                            | (1 << (ClickHouseParser.LBRAKET - 132))
                            | (1 << (ClickHouseParser.T_FLOAT32 - 132))
                            | (1 << (ClickHouseParser.T_FLOAT64 - 132))
                            | (1 << (ClickHouseParser.T_UINT8 - 132))
                            | (1 << (ClickHouseParser.T_UINT16 - 132))
                            | (1 << (ClickHouseParser.T_UINT32 - 132))
                            | (1 << (ClickHouseParser.T_UINT64 - 132))
                            | (1 << (ClickHouseParser.T_INT8 - 132))
                            | (1 << (ClickHouseParser.T_INT16 - 132))
                            | (1 << (ClickHouseParser.T_INT32 - 132))
                            | (1 << (ClickHouseParser.T_INT64 - 132))
                            | (1 << (ClickHouseParser.T_ENUM8 - 132))
                            | (1 << (ClickHouseParser.T_ENUM16 - 132))
                            | (1 << (ClickHouseParser.T_UUID - 132))
                            | (1 << (ClickHouseParser.T_DATE - 132))
                            | (1 << (ClickHouseParser.T_DATETIME - 132))
                            | (1 << (ClickHouseParser.T_STRING - 132))
                            | (1 << (ClickHouseParser.T_FIXEDSTRING - 132))
                            | (1 << (ClickHouseParser.T_NULL - 132))
                            | (1 << (ClickHouseParser.T_INTERVAL_YEAR - 132))
                            | (1 << (ClickHouseParser.T_INTERVAL_MONTH - 132))
                            | (1 << (ClickHouseParser.T_INTERVAL_WEEK - 132))
                            | (1 << (ClickHouseParser.T_INTERVAL_DAY - 132))
                            | (1 << (ClickHouseParser.T_INTERVAL_HOUR - 132))
                            | (1 << (ClickHouseParser.T_INTERVAL_MINUTE - 132))
                            | (1 << (ClickHouseParser.T_INTERVAL_SECOND - 132))
                            | (1 << (ClickHouseParser.IDENTIFIER - 132))
                            | (1 << (ClickHouseParser.NUMERIC_LITERAL - 132))
                            | (1 << (ClickHouseParser.STRING_LITERAL - 132))
                            | (1 << (ClickHouseParser.QUOTED_LITERAL - 132))
                        )
                    )
                    != 0
                )
            ):
                self.state = 1096
                self.not_empty_expression_list()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Not_empty_expression_listContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ExprContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_not_empty_expression_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNot_empty_expression_list"):
                listener.enterNot_empty_expression_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNot_empty_expression_list"):
                listener.exitNot_empty_expression_list(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNot_empty_expression_list"):
                return visitor.visitNot_empty_expression_list(self)
            else:
                return visitor.visitChildren(self)

    def not_empty_expression_list(self):

        localctx = ClickHouseParser.Not_empty_expression_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_not_empty_expression_list)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1099
            self.expr(0)
            self.state = 1104
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ClickHouseParser.COMMA:
                self.state = 1100
                self.match(ClickHouseParser.COMMA)
                self.state = 1101
                self.expr(0)
                self.state = 1106
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArrayContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRAKET(self):
            return self.getToken(ClickHouseParser.LBRAKET, 0)

        def expression_list(self):
            return self.getTypedRuleContext(ClickHouseParser.Expression_listContext, 0)

        def RBRAKET(self):
            return self.getToken(ClickHouseParser.RBRAKET, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_array

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterArray"):
                listener.enterArray(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitArray"):
                listener.exitArray(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitArray"):
                return visitor.visitArray(self)
            else:
                return visitor.visitChildren(self)

    def array(self):

        localctx = ClickHouseParser.ArrayContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_array)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1107
            self.match(ClickHouseParser.LBRAKET)
            self.state = 1108
            self.expression_list()
            self.state = 1109
            self.match(ClickHouseParser.RBRAKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def function_name(self):
            return self.getTypedRuleContext(ClickHouseParser.Function_nameContext, 0)

        def function_arguments(self):
            return self.getTypedRuleContext(ClickHouseParser.Function_argumentsContext, 0)

        def function_parameters(self):
            return self.getTypedRuleContext(ClickHouseParser.Function_parametersContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_function

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFunction"):
                listener.enterFunction(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFunction"):
                listener.exitFunction(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFunction"):
                return visitor.visitFunction(self)
            else:
                return visitor.visitChildren(self)

    def function(self):

        localctx = ClickHouseParser.FunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_function)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1111
            self.function_name()
            self.state = 1113
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 126, self._ctx)
            if la_ == 1:
                self.state = 1112
                self.function_parameters()

            self.state = 1115
            self.function_arguments()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Function_parametersContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ExprContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_function_parameters

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFunction_parameters"):
                listener.enterFunction_parameters(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFunction_parameters"):
                listener.exitFunction_parameters(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFunction_parameters"):
                return visitor.visitFunction_parameters(self)
            else:
                return visitor.visitChildren(self)

    def function_parameters(self):

        localctx = ClickHouseParser.Function_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_function_parameters)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1117
            self.match(ClickHouseParser.LPAREN)
            self.state = 1126
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (
                (
                    ((_la) & ~0x3F) == 0
                    and (
                        (1 << _la)
                        & (
                            (1 << ClickHouseParser.K_ADD)
                            | (1 << ClickHouseParser.K_AFTER)
                            | (1 << ClickHouseParser.K_ALL)
                            | (1 << ClickHouseParser.K_ALIAS)
                            | (1 << ClickHouseParser.K_ALTER)
                            | (1 << ClickHouseParser.K_AND)
                            | (1 << ClickHouseParser.K_ANY)
                            | (1 << ClickHouseParser.K_ARRAY)
                            | (1 << ClickHouseParser.K_AS)
                            | (1 << ClickHouseParser.K_ASCENDING)
                            | (1 << ClickHouseParser.K_ASC)
                            | (1 << ClickHouseParser.K_ASYNC)
                            | (1 << ClickHouseParser.K_ATTACH)
                            | (1 << ClickHouseParser.K_BETWEEN)
                            | (1 << ClickHouseParser.K_BY)
                            | (1 << ClickHouseParser.K_CASE)
                            | (1 << ClickHouseParser.K_CAST)
                            | (1 << ClickHouseParser.K_CHECK)
                            | (1 << ClickHouseParser.K_COLUMN)
                            | (1 << ClickHouseParser.K_COLLATE)
                            | (1 << ClickHouseParser.K_CREATE)
                            | (1 << ClickHouseParser.K_CROSS)
                            | (1 << ClickHouseParser.K_DESCRIBE)
                            | (1 << ClickHouseParser.K_DESCENDING)
                            | (1 << ClickHouseParser.K_DESC)
                            | (1 << ClickHouseParser.K_DATABASE)
                            | (1 << ClickHouseParser.K_DATABASES)
                            | (1 << ClickHouseParser.K_DEFAULT)
                            | (1 << ClickHouseParser.K_DETACH)
                            | (1 << ClickHouseParser.K_DISTINCT)
                            | (1 << ClickHouseParser.K_DROP)
                            | (1 << ClickHouseParser.K_ELSE)
                            | (1 << ClickHouseParser.K_END)
                            | (1 << ClickHouseParser.K_ENGINE)
                            | (1 << ClickHouseParser.K_EXISTS)
                            | (1 << ClickHouseParser.K_FINAL)
                            | (1 << ClickHouseParser.K_FIRST)
                            | (1 << ClickHouseParser.K_FROM)
                            | (1 << ClickHouseParser.K_FORMAT)
                            | (1 << ClickHouseParser.K_FULL)
                            | (1 << ClickHouseParser.K_GLOBAL)
                            | (1 << ClickHouseParser.K_GROUP)
                            | (1 << ClickHouseParser.K_HAVING)
                            | (1 << ClickHouseParser.K_ID)
                            | (1 << ClickHouseParser.K_IF)
                            | (1 << ClickHouseParser.K_INNER)
                            | (1 << ClickHouseParser.K_INSERT)
                            | (1 << ClickHouseParser.K_INTERVAL)
                            | (1 << ClickHouseParser.K_INTO)
                            | (1 << ClickHouseParser.K_IN)
                            | (1 << ClickHouseParser.K_IS)
                            | (1 << ClickHouseParser.K_JOIN)
                            | (1 << ClickHouseParser.K_KILL)
                            | (1 << ClickHouseParser.K_LAST)
                        )
                    )
                    != 0
                )
                or (
                    (((_la - 64)) & ~0x3F) == 0
                    and (
                        (1 << (_la - 64))
                        & (
                            (1 << (ClickHouseParser.K_LEFT - 64))
                            | (1 << (ClickHouseParser.K_LIKE - 64))
                            | (1 << (ClickHouseParser.K_LIMIT - 64))
                            | (1 << (ClickHouseParser.K_MAIN - 64))
                            | (1 << (ClickHouseParser.K_MATERIALIZED - 64))
                            | (1 << (ClickHouseParser.K_MODIFY - 64))
                            | (1 << (ClickHouseParser.K_NOT - 64))
                            | (1 << (ClickHouseParser.K_NULL - 64))
                            | (1 << (ClickHouseParser.K_NULLS - 64))
                            | (1 << (ClickHouseParser.K_OFFSET - 64))
                            | (1 << (ClickHouseParser.K_ON - 64))
                            | (1 << (ClickHouseParser.K_OPTIMIZE - 64))
                            | (1 << (ClickHouseParser.K_ORDER - 64))
                            | (1 << (ClickHouseParser.K_OR - 64))
                            | (1 << (ClickHouseParser.K_OUTFILE - 64))
                            | (1 << (ClickHouseParser.K_PARTITION - 64))
                            | (1 << (ClickHouseParser.K_POPULATE - 64))
                            | (1 << (ClickHouseParser.K_PREWHERE - 64))
                            | (1 << (ClickHouseParser.K_PROCESSLIST - 64))
                            | (1 << (ClickHouseParser.K_QUERY - 64))
                            | (1 << (ClickHouseParser.K_RENAME - 64))
                            | (1 << (ClickHouseParser.K_RETURN - 64))
                            | (1 << (ClickHouseParser.K_RIGHT - 64))
                            | (1 << (ClickHouseParser.K_SAMPLE - 64))
                            | (1 << (ClickHouseParser.K_SELECT - 64))
                            | (1 << (ClickHouseParser.K_SET - 64))
                            | (1 << (ClickHouseParser.K_SETTINGS - 64))
                            | (1 << (ClickHouseParser.K_SHOW - 64))
                            | (1 << (ClickHouseParser.K_SYNC - 64))
                            | (1 << (ClickHouseParser.K_TABLE - 64))
                            | (1 << (ClickHouseParser.K_TABLES - 64))
                            | (1 << (ClickHouseParser.K_TEMPORARY - 64))
                            | (1 << (ClickHouseParser.K_TEST - 64))
                            | (1 << (ClickHouseParser.K_THEN - 64))
                            | (1 << (ClickHouseParser.K_TOTALS - 64))
                            | (1 << (ClickHouseParser.K_TO - 64))
                            | (1 << (ClickHouseParser.K_OUTER - 64))
                            | (1 << (ClickHouseParser.K_VALUES - 64))
                            | (1 << (ClickHouseParser.K_VIEW - 64))
                            | (1 << (ClickHouseParser.K_UNION - 64))
                            | (1 << (ClickHouseParser.K_USE - 64))
                            | (1 << (ClickHouseParser.K_USING - 64))
                            | (1 << (ClickHouseParser.K_WHEN - 64))
                            | (1 << (ClickHouseParser.K_WHERE - 64))
                            | (1 << (ClickHouseParser.K_WITH - 64))
                            | (1 << (ClickHouseParser.LPAREN - 64))
                            | (1 << (ClickHouseParser.STAR - 64))
                        )
                    )
                    != 0
                )
                or (
                    (((_la - 132)) & ~0x3F) == 0
                    and (
                        (1 << (_la - 132))
                        & (
                            (1 << (ClickHouseParser.MINUS - 132))
                            | (1 << (ClickHouseParser.LBRAKET - 132))
                            | (1 << (ClickHouseParser.T_FLOAT32 - 132))
                            | (1 << (ClickHouseParser.T_FLOAT64 - 132))
                            | (1 << (ClickHouseParser.T_UINT8 - 132))
                            | (1 << (ClickHouseParser.T_UINT16 - 132))
                            | (1 << (ClickHouseParser.T_UINT32 - 132))
                            | (1 << (ClickHouseParser.T_UINT64 - 132))
                            | (1 << (ClickHouseParser.T_INT8 - 132))
                            | (1 << (ClickHouseParser.T_INT16 - 132))
                            | (1 << (ClickHouseParser.T_INT32 - 132))
                            | (1 << (ClickHouseParser.T_INT64 - 132))
                            | (1 << (ClickHouseParser.T_ENUM8 - 132))
                            | (1 << (ClickHouseParser.T_ENUM16 - 132))
                            | (1 << (ClickHouseParser.T_UUID - 132))
                            | (1 << (ClickHouseParser.T_DATE - 132))
                            | (1 << (ClickHouseParser.T_DATETIME - 132))
                            | (1 << (ClickHouseParser.T_STRING - 132))
                            | (1 << (ClickHouseParser.T_FIXEDSTRING - 132))
                            | (1 << (ClickHouseParser.T_NULL - 132))
                            | (1 << (ClickHouseParser.T_INTERVAL_YEAR - 132))
                            | (1 << (ClickHouseParser.T_INTERVAL_MONTH - 132))
                            | (1 << (ClickHouseParser.T_INTERVAL_WEEK - 132))
                            | (1 << (ClickHouseParser.T_INTERVAL_DAY - 132))
                            | (1 << (ClickHouseParser.T_INTERVAL_HOUR - 132))
                            | (1 << (ClickHouseParser.T_INTERVAL_MINUTE - 132))
                            | (1 << (ClickHouseParser.T_INTERVAL_SECOND - 132))
                            | (1 << (ClickHouseParser.IDENTIFIER - 132))
                            | (1 << (ClickHouseParser.NUMERIC_LITERAL - 132))
                            | (1 << (ClickHouseParser.STRING_LITERAL - 132))
                            | (1 << (ClickHouseParser.QUOTED_LITERAL - 132))
                        )
                    )
                    != 0
                )
            ):
                self.state = 1118
                self.expr(0)
                self.state = 1123
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == ClickHouseParser.COMMA:
                    self.state = 1119
                    self.match(ClickHouseParser.COMMA)
                    self.state = 1120
                    self.expr(0)
                    self.state = 1125
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

            self.state = 1128
            self.match(ClickHouseParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Function_argumentsContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(ClickHouseParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(ClickHouseParser.RPAREN, 0)

        def expr(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.ExprContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.ExprContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(ClickHouseParser.COMMA)
            else:
                return self.getToken(ClickHouseParser.COMMA, i)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_function_arguments

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFunction_arguments"):
                listener.enterFunction_arguments(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFunction_arguments"):
                listener.exitFunction_arguments(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFunction_arguments"):
                return visitor.visitFunction_arguments(self)
            else:
                return visitor.visitChildren(self)

    def function_arguments(self):

        localctx = ClickHouseParser.Function_argumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_function_arguments)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1130
            self.match(ClickHouseParser.LPAREN)
            self.state = 1139
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (
                (
                    ((_la) & ~0x3F) == 0
                    and (
                        (1 << _la)
                        & (
                            (1 << ClickHouseParser.K_ADD)
                            | (1 << ClickHouseParser.K_AFTER)
                            | (1 << ClickHouseParser.K_ALL)
                            | (1 << ClickHouseParser.K_ALIAS)
                            | (1 << ClickHouseParser.K_ALTER)
                            | (1 << ClickHouseParser.K_AND)
                            | (1 << ClickHouseParser.K_ANY)
                            | (1 << ClickHouseParser.K_ARRAY)
                            | (1 << ClickHouseParser.K_AS)
                            | (1 << ClickHouseParser.K_ASCENDING)
                            | (1 << ClickHouseParser.K_ASC)
                            | (1 << ClickHouseParser.K_ASYNC)
                            | (1 << ClickHouseParser.K_ATTACH)
                            | (1 << ClickHouseParser.K_BETWEEN)
                            | (1 << ClickHouseParser.K_BY)
                            | (1 << ClickHouseParser.K_CASE)
                            | (1 << ClickHouseParser.K_CAST)
                            | (1 << ClickHouseParser.K_CHECK)
                            | (1 << ClickHouseParser.K_COLUMN)
                            | (1 << ClickHouseParser.K_COLLATE)
                            | (1 << ClickHouseParser.K_CREATE)
                            | (1 << ClickHouseParser.K_CROSS)
                            | (1 << ClickHouseParser.K_DESCRIBE)
                            | (1 << ClickHouseParser.K_DESCENDING)
                            | (1 << ClickHouseParser.K_DESC)
                            | (1 << ClickHouseParser.K_DATABASE)
                            | (1 << ClickHouseParser.K_DATABASES)
                            | (1 << ClickHouseParser.K_DEFAULT)
                            | (1 << ClickHouseParser.K_DETACH)
                            | (1 << ClickHouseParser.K_DISTINCT)
                            | (1 << ClickHouseParser.K_DROP)
                            | (1 << ClickHouseParser.K_ELSE)
                            | (1 << ClickHouseParser.K_END)
                            | (1 << ClickHouseParser.K_ENGINE)
                            | (1 << ClickHouseParser.K_EXISTS)
                            | (1 << ClickHouseParser.K_FINAL)
                            | (1 << ClickHouseParser.K_FIRST)
                            | (1 << ClickHouseParser.K_FROM)
                            | (1 << ClickHouseParser.K_FORMAT)
                            | (1 << ClickHouseParser.K_FULL)
                            | (1 << ClickHouseParser.K_GLOBAL)
                            | (1 << ClickHouseParser.K_GROUP)
                            | (1 << ClickHouseParser.K_HAVING)
                            | (1 << ClickHouseParser.K_ID)
                            | (1 << ClickHouseParser.K_IF)
                            | (1 << ClickHouseParser.K_INNER)
                            | (1 << ClickHouseParser.K_INSERT)
                            | (1 << ClickHouseParser.K_INTERVAL)
                            | (1 << ClickHouseParser.K_INTO)
                            | (1 << ClickHouseParser.K_IN)
                            | (1 << ClickHouseParser.K_IS)
                            | (1 << ClickHouseParser.K_JOIN)
                            | (1 << ClickHouseParser.K_KILL)
                            | (1 << ClickHouseParser.K_LAST)
                        )
                    )
                    != 0
                )
                or (
                    (((_la - 64)) & ~0x3F) == 0
                    and (
                        (1 << (_la - 64))
                        & (
                            (1 << (ClickHouseParser.K_LEFT - 64))
                            | (1 << (ClickHouseParser.K_LIKE - 64))
                            | (1 << (ClickHouseParser.K_LIMIT - 64))
                            | (1 << (ClickHouseParser.K_MAIN - 64))
                            | (1 << (ClickHouseParser.K_MATERIALIZED - 64))
                            | (1 << (ClickHouseParser.K_MODIFY - 64))
                            | (1 << (ClickHouseParser.K_NOT - 64))
                            | (1 << (ClickHouseParser.K_NULL - 64))
                            | (1 << (ClickHouseParser.K_NULLS - 64))
                            | (1 << (ClickHouseParser.K_OFFSET - 64))
                            | (1 << (ClickHouseParser.K_ON - 64))
                            | (1 << (ClickHouseParser.K_OPTIMIZE - 64))
                            | (1 << (ClickHouseParser.K_ORDER - 64))
                            | (1 << (ClickHouseParser.K_OR - 64))
                            | (1 << (ClickHouseParser.K_OUTFILE - 64))
                            | (1 << (ClickHouseParser.K_PARTITION - 64))
                            | (1 << (ClickHouseParser.K_POPULATE - 64))
                            | (1 << (ClickHouseParser.K_PREWHERE - 64))
                            | (1 << (ClickHouseParser.K_PROCESSLIST - 64))
                            | (1 << (ClickHouseParser.K_QUERY - 64))
                            | (1 << (ClickHouseParser.K_RENAME - 64))
                            | (1 << (ClickHouseParser.K_RETURN - 64))
                            | (1 << (ClickHouseParser.K_RIGHT - 64))
                            | (1 << (ClickHouseParser.K_SAMPLE - 64))
                            | (1 << (ClickHouseParser.K_SELECT - 64))
                            | (1 << (ClickHouseParser.K_SET - 64))
                            | (1 << (ClickHouseParser.K_SETTINGS - 64))
                            | (1 << (ClickHouseParser.K_SHOW - 64))
                            | (1 << (ClickHouseParser.K_SYNC - 64))
                            | (1 << (ClickHouseParser.K_TABLE - 64))
                            | (1 << (ClickHouseParser.K_TABLES - 64))
                            | (1 << (ClickHouseParser.K_TEMPORARY - 64))
                            | (1 << (ClickHouseParser.K_TEST - 64))
                            | (1 << (ClickHouseParser.K_THEN - 64))
                            | (1 << (ClickHouseParser.K_TOTALS - 64))
                            | (1 << (ClickHouseParser.K_TO - 64))
                            | (1 << (ClickHouseParser.K_OUTER - 64))
                            | (1 << (ClickHouseParser.K_VALUES - 64))
                            | (1 << (ClickHouseParser.K_VIEW - 64))
                            | (1 << (ClickHouseParser.K_UNION - 64))
                            | (1 << (ClickHouseParser.K_USE - 64))
                            | (1 << (ClickHouseParser.K_USING - 64))
                            | (1 << (ClickHouseParser.K_WHEN - 64))
                            | (1 << (ClickHouseParser.K_WHERE - 64))
                            | (1 << (ClickHouseParser.K_WITH - 64))
                            | (1 << (ClickHouseParser.LPAREN - 64))
                            | (1 << (ClickHouseParser.STAR - 64))
                        )
                    )
                    != 0
                )
                or (
                    (((_la - 132)) & ~0x3F) == 0
                    and (
                        (1 << (_la - 132))
                        & (
                            (1 << (ClickHouseParser.MINUS - 132))
                            | (1 << (ClickHouseParser.LBRAKET - 132))
                            | (1 << (ClickHouseParser.T_FLOAT32 - 132))
                            | (1 << (ClickHouseParser.T_FLOAT64 - 132))
                            | (1 << (ClickHouseParser.T_UINT8 - 132))
                            | (1 << (ClickHouseParser.T_UINT16 - 132))
                            | (1 << (ClickHouseParser.T_UINT32 - 132))
                            | (1 << (ClickHouseParser.T_UINT64 - 132))
                            | (1 << (ClickHouseParser.T_INT8 - 132))
                            | (1 << (ClickHouseParser.T_INT16 - 132))
                            | (1 << (ClickHouseParser.T_INT32 - 132))
                            | (1 << (ClickHouseParser.T_INT64 - 132))
                            | (1 << (ClickHouseParser.T_ENUM8 - 132))
                            | (1 << (ClickHouseParser.T_ENUM16 - 132))
                            | (1 << (ClickHouseParser.T_UUID - 132))
                            | (1 << (ClickHouseParser.T_DATE - 132))
                            | (1 << (ClickHouseParser.T_DATETIME - 132))
                            | (1 << (ClickHouseParser.T_STRING - 132))
                            | (1 << (ClickHouseParser.T_FIXEDSTRING - 132))
                            | (1 << (ClickHouseParser.T_NULL - 132))
                            | (1 << (ClickHouseParser.T_INTERVAL_YEAR - 132))
                            | (1 << (ClickHouseParser.T_INTERVAL_MONTH - 132))
                            | (1 << (ClickHouseParser.T_INTERVAL_WEEK - 132))
                            | (1 << (ClickHouseParser.T_INTERVAL_DAY - 132))
                            | (1 << (ClickHouseParser.T_INTERVAL_HOUR - 132))
                            | (1 << (ClickHouseParser.T_INTERVAL_MINUTE - 132))
                            | (1 << (ClickHouseParser.T_INTERVAL_SECOND - 132))
                            | (1 << (ClickHouseParser.IDENTIFIER - 132))
                            | (1 << (ClickHouseParser.NUMERIC_LITERAL - 132))
                            | (1 << (ClickHouseParser.STRING_LITERAL - 132))
                            | (1 << (ClickHouseParser.QUOTED_LITERAL - 132))
                        )
                    )
                    != 0
                )
            ):
                self.state = 1131
                self.expr(0)
                self.state = 1136
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == ClickHouseParser.COMMA:
                    self.state = 1132
                    self.match(ClickHouseParser.COMMA)
                    self.state = 1133
                    self.expr(0)
                    self.state = 1138
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

            self.state = 1141
            self.match(ClickHouseParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Function_nameContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(ClickHouseParser.IdentifierContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_function_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFunction_name"):
                listener.enterFunction_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFunction_name"):
                listener.exitFunction_name(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFunction_name"):
                return visitor.visitFunction_name(self)
            else:
                return visitor.visitChildren(self)

    def function_name(self):

        localctx = ClickHouseParser.Function_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_function_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1143
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IdentifierContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUOTED_LITERAL(self):
            return self.getToken(ClickHouseParser.QUOTED_LITERAL, 0)

        def IDENTIFIER(self):
            return self.getToken(ClickHouseParser.IDENTIFIER, 0)

        def simple_type(self):
            return self.getTypedRuleContext(ClickHouseParser.Simple_typeContext, 0)

        def keyword(self):
            return self.getTypedRuleContext(ClickHouseParser.KeywordContext, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_identifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIdentifier"):
                listener.enterIdentifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIdentifier"):
                listener.exitIdentifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIdentifier"):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)

    def identifier(self):

        localctx = ClickHouseParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_identifier)
        try:
            self.state = 1149
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ClickHouseParser.QUOTED_LITERAL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1145
                self.match(ClickHouseParser.QUOTED_LITERAL)
                pass
            elif token in [ClickHouseParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1146
                self.match(ClickHouseParser.IDENTIFIER)
                pass
            elif token in [
                ClickHouseParser.T_FLOAT32,
                ClickHouseParser.T_FLOAT64,
                ClickHouseParser.T_UINT8,
                ClickHouseParser.T_UINT16,
                ClickHouseParser.T_UINT32,
                ClickHouseParser.T_UINT64,
                ClickHouseParser.T_INT8,
                ClickHouseParser.T_INT16,
                ClickHouseParser.T_INT32,
                ClickHouseParser.T_INT64,
                ClickHouseParser.T_ENUM8,
                ClickHouseParser.T_ENUM16,
                ClickHouseParser.T_UUID,
                ClickHouseParser.T_DATE,
                ClickHouseParser.T_DATETIME,
                ClickHouseParser.T_STRING,
                ClickHouseParser.T_FIXEDSTRING,
                ClickHouseParser.T_NULL,
                ClickHouseParser.T_INTERVAL_YEAR,
                ClickHouseParser.T_INTERVAL_MONTH,
                ClickHouseParser.T_INTERVAL_WEEK,
                ClickHouseParser.T_INTERVAL_DAY,
                ClickHouseParser.T_INTERVAL_HOUR,
                ClickHouseParser.T_INTERVAL_MINUTE,
                ClickHouseParser.T_INTERVAL_SECOND,
            ]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1147
                self.simple_type()
                pass
            elif token in [
                ClickHouseParser.K_ADD,
                ClickHouseParser.K_AFTER,
                ClickHouseParser.K_ALL,
                ClickHouseParser.K_ALIAS,
                ClickHouseParser.K_ALTER,
                ClickHouseParser.K_AND,
                ClickHouseParser.K_ANY,
                ClickHouseParser.K_ARRAY,
                ClickHouseParser.K_AS,
                ClickHouseParser.K_ASCENDING,
                ClickHouseParser.K_ASC,
                ClickHouseParser.K_ASYNC,
                ClickHouseParser.K_ATTACH,
                ClickHouseParser.K_BETWEEN,
                ClickHouseParser.K_BY,
                ClickHouseParser.K_CASE,
                ClickHouseParser.K_CHECK,
                ClickHouseParser.K_COLUMN,
                ClickHouseParser.K_COLLATE,
                ClickHouseParser.K_CREATE,
                ClickHouseParser.K_CROSS,
                ClickHouseParser.K_DESCRIBE,
                ClickHouseParser.K_DESCENDING,
                ClickHouseParser.K_DESC,
                ClickHouseParser.K_DATABASE,
                ClickHouseParser.K_DATABASES,
                ClickHouseParser.K_DEFAULT,
                ClickHouseParser.K_DETACH,
                ClickHouseParser.K_DISTINCT,
                ClickHouseParser.K_DROP,
                ClickHouseParser.K_ELSE,
                ClickHouseParser.K_END,
                ClickHouseParser.K_ENGINE,
                ClickHouseParser.K_EXISTS,
                ClickHouseParser.K_FINAL,
                ClickHouseParser.K_FIRST,
                ClickHouseParser.K_FROM,
                ClickHouseParser.K_FORMAT,
                ClickHouseParser.K_FULL,
                ClickHouseParser.K_GLOBAL,
                ClickHouseParser.K_GROUP,
                ClickHouseParser.K_HAVING,
                ClickHouseParser.K_ID,
                ClickHouseParser.K_IF,
                ClickHouseParser.K_INNER,
                ClickHouseParser.K_INSERT,
                ClickHouseParser.K_INTO,
                ClickHouseParser.K_IN,
                ClickHouseParser.K_IS,
                ClickHouseParser.K_JOIN,
                ClickHouseParser.K_KILL,
                ClickHouseParser.K_LAST,
                ClickHouseParser.K_LEFT,
                ClickHouseParser.K_LIKE,
                ClickHouseParser.K_LIMIT,
                ClickHouseParser.K_MAIN,
                ClickHouseParser.K_MATERIALIZED,
                ClickHouseParser.K_MODIFY,
                ClickHouseParser.K_NOT,
                ClickHouseParser.K_NULL,
                ClickHouseParser.K_NULLS,
                ClickHouseParser.K_OFFSET,
                ClickHouseParser.K_ON,
                ClickHouseParser.K_OPTIMIZE,
                ClickHouseParser.K_ORDER,
                ClickHouseParser.K_OR,
                ClickHouseParser.K_OUTFILE,
                ClickHouseParser.K_PARTITION,
                ClickHouseParser.K_POPULATE,
                ClickHouseParser.K_PREWHERE,
                ClickHouseParser.K_PROCESSLIST,
                ClickHouseParser.K_QUERY,
                ClickHouseParser.K_RENAME,
                ClickHouseParser.K_RETURN,
                ClickHouseParser.K_RIGHT,
                ClickHouseParser.K_SAMPLE,
                ClickHouseParser.K_SELECT,
                ClickHouseParser.K_SET,
                ClickHouseParser.K_SETTINGS,
                ClickHouseParser.K_SHOW,
                ClickHouseParser.K_SYNC,
                ClickHouseParser.K_TABLE,
                ClickHouseParser.K_TABLES,
                ClickHouseParser.K_TEMPORARY,
                ClickHouseParser.K_TEST,
                ClickHouseParser.K_THEN,
                ClickHouseParser.K_TOTALS,
                ClickHouseParser.K_TO,
                ClickHouseParser.K_OUTER,
                ClickHouseParser.K_VALUES,
                ClickHouseParser.K_VIEW,
                ClickHouseParser.K_UNION,
                ClickHouseParser.K_USE,
                ClickHouseParser.K_USING,
                ClickHouseParser.K_WHEN,
                ClickHouseParser.K_WHERE,
                ClickHouseParser.K_WITH,
            ]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1148
                self.keyword()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class KeywordContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_ADD(self):
            return self.getToken(ClickHouseParser.K_ADD, 0)

        def K_AFTER(self):
            return self.getToken(ClickHouseParser.K_AFTER, 0)

        def K_ALL(self):
            return self.getToken(ClickHouseParser.K_ALL, 0)

        def K_ALIAS(self):
            return self.getToken(ClickHouseParser.K_ALIAS, 0)

        def K_ALTER(self):
            return self.getToken(ClickHouseParser.K_ALTER, 0)

        def K_AND(self):
            return self.getToken(ClickHouseParser.K_AND, 0)

        def K_ANY(self):
            return self.getToken(ClickHouseParser.K_ANY, 0)

        def K_ARRAY(self):
            return self.getToken(ClickHouseParser.K_ARRAY, 0)

        def K_AS(self):
            return self.getToken(ClickHouseParser.K_AS, 0)

        def K_ASCENDING(self):
            return self.getToken(ClickHouseParser.K_ASCENDING, 0)

        def K_ASC(self):
            return self.getToken(ClickHouseParser.K_ASC, 0)

        def K_ASYNC(self):
            return self.getToken(ClickHouseParser.K_ASYNC, 0)

        def K_ATTACH(self):
            return self.getToken(ClickHouseParser.K_ATTACH, 0)

        def K_BETWEEN(self):
            return self.getToken(ClickHouseParser.K_BETWEEN, 0)

        def K_BY(self):
            return self.getToken(ClickHouseParser.K_BY, 0)

        def K_CASE(self):
            return self.getToken(ClickHouseParser.K_CASE, 0)

        def K_CHECK(self):
            return self.getToken(ClickHouseParser.K_CHECK, 0)

        def K_COLUMN(self):
            return self.getToken(ClickHouseParser.K_COLUMN, 0)

        def K_COLLATE(self):
            return self.getToken(ClickHouseParser.K_COLLATE, 0)

        def K_CREATE(self):
            return self.getToken(ClickHouseParser.K_CREATE, 0)

        def K_CROSS(self):
            return self.getToken(ClickHouseParser.K_CROSS, 0)

        def K_DESCRIBE(self):
            return self.getToken(ClickHouseParser.K_DESCRIBE, 0)

        def K_DESCENDING(self):
            return self.getToken(ClickHouseParser.K_DESCENDING, 0)

        def K_DESC(self):
            return self.getToken(ClickHouseParser.K_DESC, 0)

        def K_DATABASE(self):
            return self.getToken(ClickHouseParser.K_DATABASE, 0)

        def K_DATABASES(self):
            return self.getToken(ClickHouseParser.K_DATABASES, 0)

        def K_DEFAULT(self):
            return self.getToken(ClickHouseParser.K_DEFAULT, 0)

        def K_DETACH(self):
            return self.getToken(ClickHouseParser.K_DETACH, 0)

        def K_DISTINCT(self):
            return self.getToken(ClickHouseParser.K_DISTINCT, 0)

        def K_DROP(self):
            return self.getToken(ClickHouseParser.K_DROP, 0)

        def K_ENGINE(self):
            return self.getToken(ClickHouseParser.K_ENGINE, 0)

        def K_ELSE(self):
            return self.getToken(ClickHouseParser.K_ELSE, 0)

        def K_END(self):
            return self.getToken(ClickHouseParser.K_END, 0)

        def K_EXISTS(self):
            return self.getToken(ClickHouseParser.K_EXISTS, 0)

        def K_FINAL(self):
            return self.getToken(ClickHouseParser.K_FINAL, 0)

        def K_FIRST(self):
            return self.getToken(ClickHouseParser.K_FIRST, 0)

        def K_FROM(self):
            return self.getToken(ClickHouseParser.K_FROM, 0)

        def K_FORMAT(self):
            return self.getToken(ClickHouseParser.K_FORMAT, 0)

        def K_FULL(self):
            return self.getToken(ClickHouseParser.K_FULL, 0)

        def K_GLOBAL(self):
            return self.getToken(ClickHouseParser.K_GLOBAL, 0)

        def K_GROUP(self):
            return self.getToken(ClickHouseParser.K_GROUP, 0)

        def K_HAVING(self):
            return self.getToken(ClickHouseParser.K_HAVING, 0)

        def K_ID(self):
            return self.getToken(ClickHouseParser.K_ID, 0)

        def K_IF(self):
            return self.getToken(ClickHouseParser.K_IF, 0)

        def K_INNER(self):
            return self.getToken(ClickHouseParser.K_INNER, 0)

        def K_INSERT(self):
            return self.getToken(ClickHouseParser.K_INSERT, 0)

        def K_INTO(self):
            return self.getToken(ClickHouseParser.K_INTO, 0)

        def K_IN(self):
            return self.getToken(ClickHouseParser.K_IN, 0)

        def K_IS(self):
            return self.getToken(ClickHouseParser.K_IS, 0)

        def K_JOIN(self):
            return self.getToken(ClickHouseParser.K_JOIN, 0)

        def K_KILL(self):
            return self.getToken(ClickHouseParser.K_KILL, 0)

        def K_LAST(self):
            return self.getToken(ClickHouseParser.K_LAST, 0)

        def K_LEFT(self):
            return self.getToken(ClickHouseParser.K_LEFT, 0)

        def K_LIKE(self):
            return self.getToken(ClickHouseParser.K_LIKE, 0)

        def K_LIMIT(self):
            return self.getToken(ClickHouseParser.K_LIMIT, 0)

        def K_MAIN(self):
            return self.getToken(ClickHouseParser.K_MAIN, 0)

        def K_MATERIALIZED(self):
            return self.getToken(ClickHouseParser.K_MATERIALIZED, 0)

        def K_MODIFY(self):
            return self.getToken(ClickHouseParser.K_MODIFY, 0)

        def K_NOT(self):
            return self.getToken(ClickHouseParser.K_NOT, 0)

        def K_NULL(self):
            return self.getToken(ClickHouseParser.K_NULL, 0)

        def K_NULLS(self):
            return self.getToken(ClickHouseParser.K_NULLS, 0)

        def K_OFFSET(self):
            return self.getToken(ClickHouseParser.K_OFFSET, 0)

        def K_ON(self):
            return self.getToken(ClickHouseParser.K_ON, 0)

        def K_OPTIMIZE(self):
            return self.getToken(ClickHouseParser.K_OPTIMIZE, 0)

        def K_ORDER(self):
            return self.getToken(ClickHouseParser.K_ORDER, 0)

        def K_OR(self):
            return self.getToken(ClickHouseParser.K_OR, 0)

        def K_OUTFILE(self):
            return self.getToken(ClickHouseParser.K_OUTFILE, 0)

        def K_PARTITION(self):
            return self.getToken(ClickHouseParser.K_PARTITION, 0)

        def K_POPULATE(self):
            return self.getToken(ClickHouseParser.K_POPULATE, 0)

        def K_PREWHERE(self):
            return self.getToken(ClickHouseParser.K_PREWHERE, 0)

        def K_PROCESSLIST(self):
            return self.getToken(ClickHouseParser.K_PROCESSLIST, 0)

        def K_QUERY(self):
            return self.getToken(ClickHouseParser.K_QUERY, 0)

        def K_RENAME(self):
            return self.getToken(ClickHouseParser.K_RENAME, 0)

        def K_RETURN(self):
            return self.getToken(ClickHouseParser.K_RETURN, 0)

        def K_RIGHT(self):
            return self.getToken(ClickHouseParser.K_RIGHT, 0)

        def K_SAMPLE(self):
            return self.getToken(ClickHouseParser.K_SAMPLE, 0)

        def K_SELECT(self):
            return self.getToken(ClickHouseParser.K_SELECT, 0)

        def K_SET(self):
            return self.getToken(ClickHouseParser.K_SET, 0)

        def K_SETTINGS(self):
            return self.getToken(ClickHouseParser.K_SETTINGS, 0)

        def K_SHOW(self):
            return self.getToken(ClickHouseParser.K_SHOW, 0)

        def K_SYNC(self):
            return self.getToken(ClickHouseParser.K_SYNC, 0)

        def K_TABLE(self):
            return self.getToken(ClickHouseParser.K_TABLE, 0)

        def K_TABLES(self):
            return self.getToken(ClickHouseParser.K_TABLES, 0)

        def K_TEMPORARY(self):
            return self.getToken(ClickHouseParser.K_TEMPORARY, 0)

        def K_TEST(self):
            return self.getToken(ClickHouseParser.K_TEST, 0)

        def K_THEN(self):
            return self.getToken(ClickHouseParser.K_THEN, 0)

        def K_TOTALS(self):
            return self.getToken(ClickHouseParser.K_TOTALS, 0)

        def K_TO(self):
            return self.getToken(ClickHouseParser.K_TO, 0)

        def K_OUTER(self):
            return self.getToken(ClickHouseParser.K_OUTER, 0)

        def K_VALUES(self):
            return self.getToken(ClickHouseParser.K_VALUES, 0)

        def K_VIEW(self):
            return self.getToken(ClickHouseParser.K_VIEW, 0)

        def K_UNION(self):
            return self.getToken(ClickHouseParser.K_UNION, 0)

        def K_USE(self):
            return self.getToken(ClickHouseParser.K_USE, 0)

        def K_USING(self):
            return self.getToken(ClickHouseParser.K_USING, 0)

        def K_WHEN(self):
            return self.getToken(ClickHouseParser.K_WHEN, 0)

        def K_WHERE(self):
            return self.getToken(ClickHouseParser.K_WHERE, 0)

        def K_WITH(self):
            return self.getToken(ClickHouseParser.K_WITH, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_keyword

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterKeyword"):
                listener.enterKeyword(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitKeyword"):
                listener.exitKeyword(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitKeyword"):
                return visitor.visitKeyword(self)
            else:
                return visitor.visitChildren(self)

    def keyword(self):

        localctx = ClickHouseParser.KeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_keyword)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1151
            _la = self._input.LA(1)
            if not (
                (
                    ((_la) & ~0x3F) == 0
                    and (
                        (1 << _la)
                        & (
                            (1 << ClickHouseParser.K_ADD)
                            | (1 << ClickHouseParser.K_AFTER)
                            | (1 << ClickHouseParser.K_ALL)
                            | (1 << ClickHouseParser.K_ALIAS)
                            | (1 << ClickHouseParser.K_ALTER)
                            | (1 << ClickHouseParser.K_AND)
                            | (1 << ClickHouseParser.K_ANY)
                            | (1 << ClickHouseParser.K_ARRAY)
                            | (1 << ClickHouseParser.K_AS)
                            | (1 << ClickHouseParser.K_ASCENDING)
                            | (1 << ClickHouseParser.K_ASC)
                            | (1 << ClickHouseParser.K_ASYNC)
                            | (1 << ClickHouseParser.K_ATTACH)
                            | (1 << ClickHouseParser.K_BETWEEN)
                            | (1 << ClickHouseParser.K_BY)
                            | (1 << ClickHouseParser.K_CASE)
                            | (1 << ClickHouseParser.K_CHECK)
                            | (1 << ClickHouseParser.K_COLUMN)
                            | (1 << ClickHouseParser.K_COLLATE)
                            | (1 << ClickHouseParser.K_CREATE)
                            | (1 << ClickHouseParser.K_CROSS)
                            | (1 << ClickHouseParser.K_DESCRIBE)
                            | (1 << ClickHouseParser.K_DESCENDING)
                            | (1 << ClickHouseParser.K_DESC)
                            | (1 << ClickHouseParser.K_DATABASE)
                            | (1 << ClickHouseParser.K_DATABASES)
                            | (1 << ClickHouseParser.K_DEFAULT)
                            | (1 << ClickHouseParser.K_DETACH)
                            | (1 << ClickHouseParser.K_DISTINCT)
                            | (1 << ClickHouseParser.K_DROP)
                            | (1 << ClickHouseParser.K_ELSE)
                            | (1 << ClickHouseParser.K_END)
                            | (1 << ClickHouseParser.K_ENGINE)
                            | (1 << ClickHouseParser.K_EXISTS)
                            | (1 << ClickHouseParser.K_FINAL)
                            | (1 << ClickHouseParser.K_FIRST)
                            | (1 << ClickHouseParser.K_FROM)
                            | (1 << ClickHouseParser.K_FORMAT)
                            | (1 << ClickHouseParser.K_FULL)
                            | (1 << ClickHouseParser.K_GLOBAL)
                            | (1 << ClickHouseParser.K_GROUP)
                            | (1 << ClickHouseParser.K_HAVING)
                            | (1 << ClickHouseParser.K_ID)
                            | (1 << ClickHouseParser.K_IF)
                            | (1 << ClickHouseParser.K_INNER)
                            | (1 << ClickHouseParser.K_INSERT)
                            | (1 << ClickHouseParser.K_INTO)
                            | (1 << ClickHouseParser.K_IN)
                            | (1 << ClickHouseParser.K_IS)
                            | (1 << ClickHouseParser.K_JOIN)
                            | (1 << ClickHouseParser.K_KILL)
                            | (1 << ClickHouseParser.K_LAST)
                        )
                    )
                    != 0
                )
                or (
                    (((_la - 64)) & ~0x3F) == 0
                    and (
                        (1 << (_la - 64))
                        & (
                            (1 << (ClickHouseParser.K_LEFT - 64))
                            | (1 << (ClickHouseParser.K_LIKE - 64))
                            | (1 << (ClickHouseParser.K_LIMIT - 64))
                            | (1 << (ClickHouseParser.K_MAIN - 64))
                            | (1 << (ClickHouseParser.K_MATERIALIZED - 64))
                            | (1 << (ClickHouseParser.K_MODIFY - 64))
                            | (1 << (ClickHouseParser.K_NOT - 64))
                            | (1 << (ClickHouseParser.K_NULL - 64))
                            | (1 << (ClickHouseParser.K_NULLS - 64))
                            | (1 << (ClickHouseParser.K_OFFSET - 64))
                            | (1 << (ClickHouseParser.K_ON - 64))
                            | (1 << (ClickHouseParser.K_OPTIMIZE - 64))
                            | (1 << (ClickHouseParser.K_ORDER - 64))
                            | (1 << (ClickHouseParser.K_OR - 64))
                            | (1 << (ClickHouseParser.K_OUTFILE - 64))
                            | (1 << (ClickHouseParser.K_PARTITION - 64))
                            | (1 << (ClickHouseParser.K_POPULATE - 64))
                            | (1 << (ClickHouseParser.K_PREWHERE - 64))
                            | (1 << (ClickHouseParser.K_PROCESSLIST - 64))
                            | (1 << (ClickHouseParser.K_QUERY - 64))
                            | (1 << (ClickHouseParser.K_RENAME - 64))
                            | (1 << (ClickHouseParser.K_RETURN - 64))
                            | (1 << (ClickHouseParser.K_RIGHT - 64))
                            | (1 << (ClickHouseParser.K_SAMPLE - 64))
                            | (1 << (ClickHouseParser.K_SELECT - 64))
                            | (1 << (ClickHouseParser.K_SET - 64))
                            | (1 << (ClickHouseParser.K_SETTINGS - 64))
                            | (1 << (ClickHouseParser.K_SHOW - 64))
                            | (1 << (ClickHouseParser.K_SYNC - 64))
                            | (1 << (ClickHouseParser.K_TABLE - 64))
                            | (1 << (ClickHouseParser.K_TABLES - 64))
                            | (1 << (ClickHouseParser.K_TEMPORARY - 64))
                            | (1 << (ClickHouseParser.K_TEST - 64))
                            | (1 << (ClickHouseParser.K_THEN - 64))
                            | (1 << (ClickHouseParser.K_TOTALS - 64))
                            | (1 << (ClickHouseParser.K_TO - 64))
                            | (1 << (ClickHouseParser.K_OUTER - 64))
                            | (1 << (ClickHouseParser.K_VALUES - 64))
                            | (1 << (ClickHouseParser.K_VIEW - 64))
                            | (1 << (ClickHouseParser.K_UNION - 64))
                            | (1 << (ClickHouseParser.K_USE - 64))
                            | (1 << (ClickHouseParser.K_USING - 64))
                            | (1 << (ClickHouseParser.K_WHEN - 64))
                            | (1 << (ClickHouseParser.K_WHERE - 64))
                            | (1 << (ClickHouseParser.K_WITH - 64))
                        )
                    )
                    != 0
                )
            ):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Compound_identifierContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ClickHouseParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(ClickHouseParser.IdentifierContext, i)

        def DOT(self):
            return self.getToken(ClickHouseParser.DOT, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_compound_identifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCompound_identifier"):
                listener.enterCompound_identifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCompound_identifier"):
                listener.exitCompound_identifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCompound_identifier"):
                return visitor.visitCompound_identifier(self)
            else:
                return visitor.visitChildren(self)

    def compound_identifier(self):

        localctx = ClickHouseParser.Compound_identifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_compound_identifier)
        try:
            self.state = 1158
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 132, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1153
                self.identifier()
                self.state = 1154
                self.match(ClickHouseParser.DOT)
                self.state = 1155
                self.identifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1157
                self.identifier()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LiteralContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_NULL(self):
            return self.getToken(ClickHouseParser.K_NULL, 0)

        def NUMERIC_LITERAL(self):
            return self.getToken(ClickHouseParser.NUMERIC_LITERAL, 0)

        def STRING_LITERAL(self):
            return self.getToken(ClickHouseParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_literal

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLiteral"):
                listener.enterLiteral(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLiteral"):
                listener.exitLiteral(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLiteral"):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)

    def literal(self):

        localctx = ClickHouseParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_literal)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1160
            _la = self._input.LA(1)
            if not (
                _la == ClickHouseParser.K_NULL
                or _la == ClickHouseParser.NUMERIC_LITERAL
                or _la == ClickHouseParser.STRING_LITERAL
            ):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ErrContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._UNEXPECTED_CHAR = None  # Token

        def UNEXPECTED_CHAR(self):
            return self.getToken(ClickHouseParser.UNEXPECTED_CHAR, 0)

        def getRuleIndex(self):
            return ClickHouseParser.RULE_err

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterErr"):
                listener.enterErr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitErr"):
                listener.exitErr(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitErr"):
                return visitor.visitErr(self)
            else:
                return visitor.visitChildren(self)

    def err(self):

        localctx = ClickHouseParser.ErrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_err)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1162
            localctx._UNEXPECTED_CHAR = self.match(ClickHouseParser.UNEXPECTED_CHAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    def sempred(self, localctx: RuleContext, ruleIndex: int, predIndex: int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[71] = self.expr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expr_sempred(self, localctx: ExprContext, predIndex: int):
        if predIndex == 0:
            return self.precpred(self._ctx, 24)

        if predIndex == 1:
            return self.precpred(self._ctx, 20)

        if predIndex == 2:
            return self.precpred(self._ctx, 19)

        if predIndex == 3:
            return self.precpred(self._ctx, 18)

        if predIndex == 4:
            return self.precpred(self._ctx, 17)

        if predIndex == 5:
            return self.precpred(self._ctx, 16)

        if predIndex == 6:
            return self.precpred(self._ctx, 15)

        if predIndex == 7:
            return self.precpred(self._ctx, 11)

        if predIndex == 8:
            return self.precpred(self._ctx, 10)

        if predIndex == 9:
            return self.precpred(self._ctx, 9)

        if predIndex == 10:
            return self.precpred(self._ctx, 23)

        if predIndex == 11:
            return self.precpred(self._ctx, 14)

        if predIndex == 12:
            return self.precpred(self._ctx, 1)
